"""Implementation of statechart model.
Generated by itemis CREATE code generator.
"""

import queue
import sys, os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))

class Model:
	"""Implementation of the state machine Model.
	"""

	class State:
		""" State Enum
		"""
		(
			xmanual_control,
			xmanual_control_manual_control_region_idle,
			xmanual_control_manual_control_region_in_action,
			xmanual_control_manual_control_region_decreasing_speed,
			xmanual_control_manual_control_region_increasing_speed,
			xmanual_control_manual_control_region_turning_right,
			xmanual_control_manual_control_region_turning_left,
			xautomatic_moving,
			xautomatic_moving_row_calcualtion_base_state,
			xautomatic_moving_row_calcualtion_calc,
			xautomatic_moving_row_calcualtion_zero,
			xautomatic_moving_row_calcualtion_one,
			xautomatic_moving_row_calcualtion_two,
			xautomatic_moving_row_calcualtion_three,
			xautomatic_moving_column_calculation_base_state,
			xautomatic_moving_column_calculation_calc,
			xautomatic_moving_column_calculation_zero,
			xautomatic_moving_column_calculation_one,
			xautomatic_moving_column_calculation_two,
			xautomatic_moving_column_calculation_three,
			xautomatic_moving_direction_calculation_calc,
			xautomatic_moving_direction_calculation_north,
			xautomatic_moving_direction_calculation_south,
			xautomatic_moving_direction_calculation_west,
			xautomatic_moving_direction_calculation_east,
			xautomatic_moving_direction_calculation_base,
			xautomatic_moving_grid_interaction_unlogging,
			xautomatic_moving_grid_interaction_logging,
			xautomatic_moving_grid_interaction_logging_r1first,
			xautomatic_moving_grid_interaction_logging_r1second,
			xautomatic_moving_grid_interaction_pr,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging,
			xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell,
			xautomatic_moving_automatic_moving_through_maze_prom,
			xautomatic_moving_automatic_moving_through_maze_turning_south,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go,
			xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished,
			xautomatic_moving_automatic_moving_through_maze_turning_left,
			xautomatic_moving_move_normal,
			xautomatic_moving_move_moving_full,
			xautomatic_moving_move_precise,
			xautomatic_moving_move_precise2,
			xautomatic_moving_turn_high_level_normal,
			xautomatic_moving_turn_high_level_turn_left,
			xautomatic_moving_turn_high_level_turn_right,
			xautomatic_moving_turn_high_level_turn_back,
			xautomatic_moving_turn_high_level_processing_angle,
			xautomatic_moving_turn_high_level_plus,
			xautomatic_moving_turn_high_level_minus,
			xautomatic_moving_turn_high_level_processing_angle2,
			xautomatic_moving_turn_low_level_base_state,
			xautomatic_moving_turn_low_level_turn_to_negative_angle,
			xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position,
			xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step,
			xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step,
			xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step,
			xautomatic_moving_turn_low_level_turn_to_positive_angle,
			xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position,
			xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step,
			xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step,
			xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step,
			xautomatic_moving_turn_low_level_finished_turn,
			xcalibration,
			xcalibration_calibration_calibrate,
			xcalibration_calibration_maze_orientation,
			null_state
		) = range(81)
	
	
	class UserVar:
		"""Implementation of scope UserVar.
		"""
		
		def __init__(self, statemachine):
			self.is_calibrated = None
			self.maze_orientation = None
			self.base_speed = None
			self.base_rotation = None
			self.startprocedure = None
			self.am_x_mem = None
			self.am_y_mem = None
			self.am_angle_targ = None
			self.am_gl_row_rel = None
			self.am_gl_col_rel = None
			self.am_gl_ang = None
			self.am_row_stop = None
			self.am_col_stop = None
			
			self.statemachine = statemachine
		
	
	class BaseValues:
		"""Implementation of scope BaseValues.
		"""
		
		def __init__(self, statemachine):
			self.max_speed = None
			self.max_rotation = None
			self.degrees_front = None
			self.degrees_right = None
			self.degrees_back = None
			self.degrees_left = None
			
			self.statemachine = statemachine
		
	
	class Output:
		"""Implementation of scope Output.
		"""
		
		def __init__(self, statemachine):
			self.speed = None
			self.rotation = None
			self.obstacles = None
			self.gems = None
			self.finish = None
			
			self.statemachine = statemachine
		
	
	class Grid:
		"""Implementation of scope Grid.
		"""
		
		def __init__(self, statemachine):
			self.update = None
			self.receive = None
			self.column = None
			self.row = None
			self.orientation = None
			self.visited = None
			self.wall_front = None
			self.wall_right = None
			self.wall_back = None
			self.wall_left = None
			self.grid_size = None
			self.max_col = None
			self.max_row = None
			
			self.statemachine = statemachine
		
	
	class StartPos:
		"""Implementation of scope StartPos.
		"""
		
		def __init__(self, statemachine):
			self.set_zero = None
			self.zero_x = None
			self.zero_y = None
			self.zero_south_degree = None
			self.laser_deg_offset = None
			
			self.statemachine = statemachine
		
	
	class Computer:
		"""Implementation of scope Computer.
		"""
		
		def __init__(self, statemachine):
			self.m_press = None
			self.w_press = None
			self.a_press = None
			self.s_press = None
			self.d_press = None
			self.x_press = None
			
			self.statemachine = statemachine
		
		def raise_m_press(self):
			"""Raise method for event m_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_m_press_call)
			self.statemachine.run_cycle()
		
		def __raise_m_press_call(self):
			"""Raise callback for event m_press.
			"""
			self.m_press = True
		
		def raise_w_press(self):
			"""Raise method for event w_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_w_press_call)
			self.statemachine.run_cycle()
		
		def __raise_w_press_call(self):
			"""Raise callback for event w_press.
			"""
			self.w_press = True
		
		def raise_a_press(self):
			"""Raise method for event a_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_a_press_call)
			self.statemachine.run_cycle()
		
		def __raise_a_press_call(self):
			"""Raise callback for event a_press.
			"""
			self.a_press = True
		
		def raise_s_press(self):
			"""Raise method for event s_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_s_press_call)
			self.statemachine.run_cycle()
		
		def __raise_s_press_call(self):
			"""Raise callback for event s_press.
			"""
			self.s_press = True
		
		def raise_d_press(self):
			"""Raise method for event d_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_d_press_call)
			self.statemachine.run_cycle()
		
		def __raise_d_press_call(self):
			"""Raise callback for event d_press.
			"""
			self.d_press = True
		
		def raise_x_press(self):
			"""Raise method for event x_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_x_press_call)
			self.statemachine.run_cycle()
		
		def __raise_x_press_call(self):
			"""Raise callback for event x_press.
			"""
			self.x_press = True
		
	
	class Imu:
		"""Implementation of scope Imu.
		"""
		
		def __init__(self, statemachine):
			self.pitch = None
			self.roll = None
			self.yaw = None
			
			self.statemachine = statemachine
		
	
	class Odom:
		"""Implementation of scope Odom.
		"""
		
		def __init__(self, statemachine):
			self.x = None
			self.y = None
			self.z = None
			
			self.statemachine = statemachine
		
	
	class LaserDistance:
		"""Implementation of scope LaserDistance.
		"""
		
		def __init__(self, statemachine):
			self.d0 = None
			self.d90 = None
			self.d180 = None
			self.dm90 = None
			self.dmin = None
			self.min_deg = None
			self.dmax = None
			self.max_deg = None
			self.dmean = None
			self.dfront_min = None
			self.min_deg_f = None
			self.dfront_max = None
			self.max_deg_f = None
			self.dfront_mean = None
			self.dright_min = None
			self.min_deg_r = None
			self.dright_max = None
			self.max_deg_r = None
			self.dright_mean = None
			self.dback_min = None
			self.min_deg_b = None
			self.dback_max = None
			self.max_deg_b = None
			self.dback_mean = None
			self.dleft_min = None
			self.min_deg_l = None
			self.dleft_max = None
			self.max_deg_l = None
			self.dleft_mean = None
			
			self.statemachine = statemachine
		
	
	class LaserIntensity:
		"""Implementation of scope LaserIntensity.
		"""
		
		def __init__(self, statemachine):
			self.i0 = None
			self.i90 = None
			self.i180 = None
			self.im90 = None
			self.ifront_min = None
			self.ifront_max = None
			self.ifront_mean = None
			self.iright_min = None
			self.iright_max = None
			self.iright_mean = None
			self.iback_min = None
			self.iback_max = None
			self.iback_mean = None
			self.ileft_min = None
			self.ileft_max = None
			self.ileft_mean = None
			
			self.statemachine = statemachine
		
	
	def __init__(self):
		""" Declares all necessary variables including list of states, histories etc. 
		"""
		self.user_var = Model.UserVar(self)
		self.base_values = Model.BaseValues(self)
		self.output = Model.Output(self)
		self.grid = Model.Grid(self)
		self.start_pos = Model.StartPos(self)
		self.computer = Model.Computer(self)
		self.imu = Model.Imu(self)
		self.odom = Model.Odom(self)
		self.laser_distance = Model.LaserDistance(self)
		self.laser_intensity = Model.LaserIntensity(self)
		
		self.__internal_event_queue = queue.Queue()
		self.in_event_queue = queue.Queue()
		self.am_turn_left = None
		self.am_turn_right = None
		self.am_turn_back = None
		self.am_start_turn = None
		self.am_finished_turn = None
		self.am_move_gr = None
		self.am_finished_move = None
		self.am_gl_update_dat = None
		self.am_gl_log = None
		self.am_gl_logged = None
		
		# enumeration of all states:
		self.__State = Model.State
		self.__state_conf_vector_changed = None
		self.__state_vector = [None] * 8
		for __state_index in range(8):
			self.__state_vector[__state_index] = self.State.null_state
		
		# for timed statechart:
		self.timer_service = None
		self.__time_events = [None] * 10
		
		# initializations:
		#Default init sequence for statechart model
		self.user_var.is_calibrated = False
		self.user_var.maze_orientation = 0
		self.user_var.base_speed = 0.2
		self.user_var.base_rotation = 0.4
		self.user_var.startprocedure = True
		self.user_var.am_x_mem = 0.0
		self.user_var.am_y_mem = 0.0
		self.user_var.am_angle_targ = 0
		self.user_var.am_gl_row_rel = -(1.0)
		self.user_var.am_gl_col_rel = -(1.0)
		self.user_var.am_gl_ang = 0
		self.user_var.am_row_stop = 3
		self.user_var.am_col_stop = 3
		self.base_values.max_speed = 0.22
		self.base_values.max_rotation = 2.84
		self.base_values.degrees_front = 10
		self.base_values.degrees_right = 10
		self.base_values.degrees_back = 10
		self.base_values.degrees_left = 10
		self.output.speed = 0.0
		self.output.rotation = 0.0
		self.output.obstacles = 0
		self.output.gems = 0
		self.output.finish = 0
		self.grid.update = False
		self.grid.receive = False
		self.grid.column = 0
		self.grid.row = 0
		self.grid.orientation = 0
		self.grid.visited = False
		self.grid.wall_front = 0
		self.grid.wall_right = 0
		self.grid.wall_back = 0
		self.grid.wall_left = 0
		self.grid.grid_size = 0.48
		self.grid.max_col = 3
		self.grid.max_row = 3
		self.start_pos.set_zero = False
		self.start_pos.zero_x = 0.0
		self.start_pos.zero_y = 0.0
		self.start_pos.zero_south_degree = 0.0
		self.start_pos.laser_deg_offset = 0
		self.imu.pitch = 0.0
		self.imu.roll = 0.0
		self.imu.yaw = 0.0
		self.odom.x = 0.0
		self.odom.y = 0.0
		self.odom.z = 0.0
		self.laser_distance.d0 = 0.0
		self.laser_distance.d90 = 0.0
		self.laser_distance.d180 = 0.0
		self.laser_distance.dm90 = 0.0
		self.laser_distance.dmin = 0.0
		self.laser_distance.min_deg = 0
		self.laser_distance.dmax = 0.0
		self.laser_distance.max_deg = 0
		self.laser_distance.dmean = 0.0
		self.laser_distance.dfront_min = 0.0
		self.laser_distance.min_deg_f = 0
		self.laser_distance.dfront_max = 0.0
		self.laser_distance.max_deg_f = 0
		self.laser_distance.dfront_mean = 0.0
		self.laser_distance.dright_min = 0.0
		self.laser_distance.min_deg_r = 0
		self.laser_distance.dright_max = 0.0
		self.laser_distance.max_deg_r = 0
		self.laser_distance.dright_mean = 0.0
		self.laser_distance.dback_min = 0.0
		self.laser_distance.min_deg_b = 0
		self.laser_distance.dback_max = 0.0
		self.laser_distance.max_deg_b = 0
		self.laser_distance.dback_mean = 0.0
		self.laser_distance.dleft_min = 0.0
		self.laser_distance.min_deg_l = 0
		self.laser_distance.dleft_max = 0.0
		self.laser_distance.max_deg_l = 0
		self.laser_distance.dleft_mean = 0.0
		self.laser_intensity.i0 = 0.0
		self.laser_intensity.i90 = 0.0
		self.laser_intensity.i180 = 0.0
		self.laser_intensity.im90 = 0.0
		self.laser_intensity.ifront_min = 0.0
		self.laser_intensity.ifront_max = 0.0
		self.laser_intensity.ifront_mean = 0.0
		self.laser_intensity.iright_min = 0.0
		self.laser_intensity.iright_max = 0.0
		self.laser_intensity.iright_mean = 0.0
		self.laser_intensity.iback_min = 0.0
		self.laser_intensity.iback_max = 0.0
		self.laser_intensity.iback_mean = 0.0
		self.laser_intensity.ileft_min = 0.0
		self.laser_intensity.ileft_max = 0.0
		self.laser_intensity.ileft_mean = 0.0
		self.__completed = False
		self.__do_completion = False
		self.__is_executing = False
		self.__state_conf_vector_position = None
	
	def is_active(self):
		"""Checks if the state machine is active.
		"""
		return self.__state_vector[0] is not self.__State.null_state or self.__state_vector[1] is not self.__State.null_state or self.__state_vector[2] is not self.__State.null_state or self.__state_vector[3] is not self.__State.null_state or self.__state_vector[4] is not self.__State.null_state or self.__state_vector[5] is not self.__State.null_state or self.__state_vector[6] is not self.__State.null_state or self.__state_vector[7] is not self.__State.null_state
	
	def is_final(self):
		"""Checks if the statemachine is final.
		Always returns 'false' since this state machine can never become final.
		"""
		return False
			
	def is_state_active(self, state):
		"""Checks if the state is currently active.
		"""
		s = state
		if s == self.__State.xmanual_control:
			return (self.__state_vector[0] >= self.__State.xmanual_control)\
				and (self.__state_vector[0] <= self.__State.xmanual_control_manual_control_region_turning_left)
		if s == self.__State.xmanual_control_manual_control_region_idle:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_idle
		if s == self.__State.xmanual_control_manual_control_region_in_action:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_in_action
		if s == self.__State.xmanual_control_manual_control_region_decreasing_speed:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_decreasing_speed
		if s == self.__State.xmanual_control_manual_control_region_increasing_speed:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_increasing_speed
		if s == self.__State.xmanual_control_manual_control_region_turning_right:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_turning_right
		if s == self.__State.xmanual_control_manual_control_region_turning_left:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_turning_left
		if s == self.__State.xautomatic_moving:
			return (self.__state_vector[0] >= self.__State.xautomatic_moving)\
				and (self.__state_vector[0] <= self.__State.xautomatic_moving_turn_low_level_finished_turn)
		if s == self.__State.xautomatic_moving_row_calcualtion_base_state:
			return self.__state_vector[0] == self.__State.xautomatic_moving_row_calcualtion_base_state
		if s == self.__State.xautomatic_moving_row_calcualtion_calc:
			return self.__state_vector[0] == self.__State.xautomatic_moving_row_calcualtion_calc
		if s == self.__State.xautomatic_moving_row_calcualtion_zero:
			return self.__state_vector[0] == self.__State.xautomatic_moving_row_calcualtion_zero
		if s == self.__State.xautomatic_moving_row_calcualtion_one:
			return self.__state_vector[0] == self.__State.xautomatic_moving_row_calcualtion_one
		if s == self.__State.xautomatic_moving_row_calcualtion_two:
			return self.__state_vector[0] == self.__State.xautomatic_moving_row_calcualtion_two
		if s == self.__State.xautomatic_moving_row_calcualtion_three:
			return self.__state_vector[0] == self.__State.xautomatic_moving_row_calcualtion_three
		if s == self.__State.xautomatic_moving_column_calculation_base_state:
			return self.__state_vector[1] == self.__State.xautomatic_moving_column_calculation_base_state
		if s == self.__State.xautomatic_moving_column_calculation_calc:
			return self.__state_vector[1] == self.__State.xautomatic_moving_column_calculation_calc
		if s == self.__State.xautomatic_moving_column_calculation_zero:
			return self.__state_vector[1] == self.__State.xautomatic_moving_column_calculation_zero
		if s == self.__State.xautomatic_moving_column_calculation_one:
			return self.__state_vector[1] == self.__State.xautomatic_moving_column_calculation_one
		if s == self.__State.xautomatic_moving_column_calculation_two:
			return self.__state_vector[1] == self.__State.xautomatic_moving_column_calculation_two
		if s == self.__State.xautomatic_moving_column_calculation_three:
			return self.__state_vector[1] == self.__State.xautomatic_moving_column_calculation_three
		if s == self.__State.xautomatic_moving_direction_calculation_calc:
			return self.__state_vector[2] == self.__State.xautomatic_moving_direction_calculation_calc
		if s == self.__State.xautomatic_moving_direction_calculation_north:
			return self.__state_vector[2] == self.__State.xautomatic_moving_direction_calculation_north
		if s == self.__State.xautomatic_moving_direction_calculation_south:
			return self.__state_vector[2] == self.__State.xautomatic_moving_direction_calculation_south
		if s == self.__State.xautomatic_moving_direction_calculation_west:
			return self.__state_vector[2] == self.__State.xautomatic_moving_direction_calculation_west
		if s == self.__State.xautomatic_moving_direction_calculation_east:
			return self.__state_vector[2] == self.__State.xautomatic_moving_direction_calculation_east
		if s == self.__State.xautomatic_moving_direction_calculation_base:
			return self.__state_vector[2] == self.__State.xautomatic_moving_direction_calculation_base
		if s == self.__State.xautomatic_moving_grid_interaction_unlogging:
			return self.__state_vector[3] == self.__State.xautomatic_moving_grid_interaction_unlogging
		if s == self.__State.xautomatic_moving_grid_interaction_logging:
			return (self.__state_vector[3] >= self.__State.xautomatic_moving_grid_interaction_logging)\
				and (self.__state_vector[3] <= self.__State.xautomatic_moving_grid_interaction_logging_r1second)
		if s == self.__State.xautomatic_moving_grid_interaction_logging_r1first:
			return self.__state_vector[3] == self.__State.xautomatic_moving_grid_interaction_logging_r1first
		if s == self.__State.xautomatic_moving_grid_interaction_logging_r1second:
			return self.__state_vector[3] == self.__State.xautomatic_moving_grid_interaction_logging_r1second
		if s == self.__State.xautomatic_moving_grid_interaction_pr:
			return self.__state_vector[3] == self.__State.xautomatic_moving_grid_interaction_pr
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar:
			return (self.__state_vector[4] >= self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar)\
				and (self.__state_vector[4] <= self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell)
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_prom:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_prom
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_turning_south:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_turning_south
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar:
			return (self.__state_vector[4] >= self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar)\
				and (self.__state_vector[4] <= self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished)
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished
		if s == self.__State.xautomatic_moving_automatic_moving_through_maze_turning_left:
			return self.__state_vector[4] == self.__State.xautomatic_moving_automatic_moving_through_maze_turning_left
		if s == self.__State.xautomatic_moving_move_normal:
			return self.__state_vector[5] == self.__State.xautomatic_moving_move_normal
		if s == self.__State.xautomatic_moving_move_moving_full:
			return self.__state_vector[5] == self.__State.xautomatic_moving_move_moving_full
		if s == self.__State.xautomatic_moving_move_precise:
			return self.__state_vector[5] == self.__State.xautomatic_moving_move_precise
		if s == self.__State.xautomatic_moving_move_precise2:
			return self.__state_vector[5] == self.__State.xautomatic_moving_move_precise2
		if s == self.__State.xautomatic_moving_turn_high_level_normal:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_normal
		if s == self.__State.xautomatic_moving_turn_high_level_turn_left:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_turn_left
		if s == self.__State.xautomatic_moving_turn_high_level_turn_right:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_turn_right
		if s == self.__State.xautomatic_moving_turn_high_level_turn_back:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_turn_back
		if s == self.__State.xautomatic_moving_turn_high_level_processing_angle:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_processing_angle
		if s == self.__State.xautomatic_moving_turn_high_level_plus:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_plus
		if s == self.__State.xautomatic_moving_turn_high_level_minus:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_minus
		if s == self.__State.xautomatic_moving_turn_high_level_processing_angle2:
			return self.__state_vector[6] == self.__State.xautomatic_moving_turn_high_level_processing_angle2
		if s == self.__State.xautomatic_moving_turn_low_level_base_state:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_base_state
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle:
			return (self.__state_vector[7] >= self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle)\
				and (self.__state_vector[7] <= self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step)
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle:
			return (self.__state_vector[7] >= self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle)\
				and (self.__state_vector[7] <= self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step)
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step
		if s == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step
		if s == self.__State.xautomatic_moving_turn_low_level_finished_turn:
			return self.__state_vector[7] == self.__State.xautomatic_moving_turn_low_level_finished_turn
		if s == self.__State.xcalibration:
			return (self.__state_vector[0] >= self.__State.xcalibration)\
				and (self.__state_vector[0] <= self.__State.xcalibration_calibration_maze_orientation)
		if s == self.__State.xcalibration_calibration_calibrate:
			return self.__state_vector[0] == self.__State.xcalibration_calibration_calibrate
		if s == self.__State.xcalibration_calibration_maze_orientation:
			return self.__state_vector[0] == self.__State.xcalibration_calibration_maze_orientation
		return False
		
	def time_elapsed(self, event_id):
		"""Add time events to in event queue
		"""
		if event_id in range(10):
			self.in_event_queue.put(lambda: self.raise_time_event(event_id))
			self.run_cycle()
	
	def raise_time_event(self, event_id):
		"""Raise timed events using the event_id.
		"""
		self.__time_events[event_id] = True
	
	def __execute_queued_event(self, func):
		func()
	
	def __get_next_event(self):
		if not self.__internal_event_queue.empty():
			return self.__internal_event_queue.get()
		if not self.in_event_queue.empty():
			return self.in_event_queue.get()
		return None
	
	
	def raise_am_turn_left(self):
		"""Raise method for event am_turn_left.
		"""
		self.__internal_event_queue.put(self.__raise_am_turn_left_call)
	
	def __raise_am_turn_left_call(self):
		"""Raise callback for event am_turn_left.
		"""
		self.am_turn_left = True
	
	def raise_am_turn_right(self):
		"""Raise method for event am_turn_right.
		"""
		self.__internal_event_queue.put(self.__raise_am_turn_right_call)
	
	def __raise_am_turn_right_call(self):
		"""Raise callback for event am_turn_right.
		"""
		self.am_turn_right = True
	
	def raise_am_turn_back(self):
		"""Raise method for event am_turn_back.
		"""
		self.__internal_event_queue.put(self.__raise_am_turn_back_call)
	
	def __raise_am_turn_back_call(self):
		"""Raise callback for event am_turn_back.
		"""
		self.am_turn_back = True
	
	def raise_am_start_turn(self):
		"""Raise method for event am_start_turn.
		"""
		self.__internal_event_queue.put(self.__raise_am_start_turn_call)
	
	def __raise_am_start_turn_call(self):
		"""Raise callback for event am_start_turn.
		"""
		self.am_start_turn = True
	
	def raise_am_finished_turn(self):
		"""Raise method for event am_finished_turn.
		"""
		self.__internal_event_queue.put(self.__raise_am_finished_turn_call)
	
	def __raise_am_finished_turn_call(self):
		"""Raise callback for event am_finished_turn.
		"""
		self.am_finished_turn = True
	
	def raise_am_move_gr(self):
		"""Raise method for event am_move_gr.
		"""
		self.__internal_event_queue.put(self.__raise_am_move_gr_call)
	
	def __raise_am_move_gr_call(self):
		"""Raise callback for event am_move_gr.
		"""
		self.am_move_gr = True
	
	def raise_am_finished_move(self):
		"""Raise method for event am_finished_move.
		"""
		self.__internal_event_queue.put(self.__raise_am_finished_move_call)
	
	def __raise_am_finished_move_call(self):
		"""Raise callback for event am_finished_move.
		"""
		self.am_finished_move = True
	
	def raise_am_gl_update_dat(self):
		"""Raise method for event am_gl_update_dat.
		"""
		self.__internal_event_queue.put(self.__raise_am_gl_update_dat_call)
	
	def __raise_am_gl_update_dat_call(self):
		"""Raise callback for event am_gl_update_dat.
		"""
		self.am_gl_update_dat = True
	
	def raise_am_gl_log(self):
		"""Raise method for event am_gl_log.
		"""
		self.__internal_event_queue.put(self.__raise_am_gl_log_call)
	
	def __raise_am_gl_log_call(self):
		"""Raise callback for event am_gl_log.
		"""
		self.am_gl_log = True
	
	def raise_am_gl_logged(self):
		"""Raise method for event am_gl_logged.
		"""
		self.__internal_event_queue.put(self.__raise_am_gl_logged_call)
	
	def __raise_am_gl_logged_call(self):
		"""Raise callback for event am_gl_logged.
		"""
		self.am_gl_logged = True
	
	def __entry_action_x_manual_control_manual_control_region_idle(self):
		"""Entry action for state 'Idle'..
		"""
		#Entry action for state 'Idle'.
		self.output.speed = 0.0
		self.output.rotation = 0.0
		
	def __entry_action_x_manual_control_manual_control_region_decreasing_speed(self):
		""".
		"""
		#Entry action for state 'Decreasing speed'.
		self.output.speed = (self.output.speed - 0.02) if self.output.speed > 0.02 else 0.0
		self.__completed = True
		
	def __entry_action_x_manual_control_manual_control_region_increasing_speed(self):
		""".
		"""
		#Entry action for state 'Increasing speed'.
		self.output.speed = (self.output.speed + 0.02) if self.output.speed < 0.2 else 0.22
		self.__completed = True
		
	def __entry_action_x_manual_control_manual_control_region_turning_right(self):
		""".
		"""
		#Entry action for state 'Turning right'.
		self.output.rotation = (self.output.rotation - 0.02) if self.output.rotation > -(2.82) else -(2.84)
		self.__completed = True
		
	def __entry_action_x_manual_control_manual_control_region_turning_left(self):
		""".
		"""
		#Entry action for state 'Turning left'.
		self.output.rotation = (self.output.rotation + 0.02) if self.output.rotation < 2.82 else 2.84
		self.__completed = True
		
	def __entry_action_x_automatic_moving_row_calcualtion_calc(self):
		"""Entry action for state 'calc'..
		"""
		#Entry action for state 'calc'.
		self.timer_service.set_timer(self, 0, (100 * 1000), False)
		self.user_var.am_gl_row_rel = ((((self.odom.x - self.start_pos.zero_x)) if (self.odom.x > self.start_pos.zero_x) else ((self.start_pos.zero_x - self.odom.x))) / self.grid.grid_size) if (self.user_var.maze_orientation == 0) else ((((self.odom.y - self.start_pos.zero_y)) if (self.odom.y > self.start_pos.zero_y) else ((self.start_pos.zero_y - self.odom.y))) / self.grid.grid_size)
		
	def __entry_action_x_automatic_moving_row_calcualtion_zero(self):
		""".
		"""
		#Entry action for state 'zero'.
		self.grid.row = 0
		self.__completed = True
		
	def __entry_action_x_automatic_moving_row_calcualtion_one(self):
		""".
		"""
		#Entry action for state 'one'.
		self.grid.row = 1
		self.__completed = True
		
	def __entry_action_x_automatic_moving_row_calcualtion_two(self):
		""".
		"""
		#Entry action for state 'two'.
		self.grid.row = 2
		self.__completed = True
		
	def __entry_action_x_automatic_moving_row_calcualtion_three(self):
		""".
		"""
		#Entry action for state 'three'.
		self.grid.row = 3
		self.__completed = True
		
	def __entry_action_x_automatic_moving_column_calculation_calc(self):
		"""Entry action for state 'calc'..
		"""
		#Entry action for state 'calc'.
		self.timer_service.set_timer(self, 1, (100 * 1000), False)
		self.user_var.am_gl_col_rel = ((((self.odom.x - self.start_pos.zero_x)) if (self.odom.x > self.start_pos.zero_x) else ((self.start_pos.zero_x - self.odom.x))) / self.grid.grid_size) if (self.user_var.maze_orientation == 1) else ((((self.odom.y - self.start_pos.zero_y)) if (self.odom.y > self.start_pos.zero_y) else ((self.start_pos.zero_y - self.odom.y))) / self.grid.grid_size)
		
	def __entry_action_x_automatic_moving_column_calculation_zero(self):
		""".
		"""
		#Entry action for state 'zero'.
		self.grid.column = 0
		self.__completed = True
		
	def __entry_action_x_automatic_moving_column_calculation_one(self):
		""".
		"""
		#Entry action for state 'one'.
		self.grid.column = 1
		self.__completed = True
		
	def __entry_action_x_automatic_moving_column_calculation_two(self):
		""".
		"""
		#Entry action for state 'two'.
		self.grid.column = 2
		self.__completed = True
		
	def __entry_action_x_automatic_moving_column_calculation_three(self):
		""".
		"""
		#Entry action for state 'three'.
		self.grid.column = 3
		self.__completed = True
		
	def __entry_action_x_automatic_moving_direction_calculation_calc(self):
		"""Entry action for state 'calc'..
		"""
		#Entry action for state 'calc'.
		self.timer_service.set_timer(self, 2, (100 * 1000), False)
		self.user_var.am_gl_ang = (((int((((self.imu.yaw + 720) - self.start_pos.zero_south_degree))))) % 360)
		
	def __entry_action_x_automatic_moving_direction_calculation_north(self):
		""".
		"""
		#Entry action for state 'north'.
		self.grid.orientation = 0
		self.__completed = True
		
	def __entry_action_x_automatic_moving_direction_calculation_south(self):
		""".
		"""
		#Entry action for state 'south'.
		self.grid.orientation = 2
		self.__completed = True
		
	def __entry_action_x_automatic_moving_direction_calculation_west(self):
		""".
		"""
		#Entry action for state 'west'.
		self.grid.orientation = 1
		self.__completed = True
		
	def __entry_action_x_automatic_moving_direction_calculation_east(self):
		""".
		"""
		#Entry action for state 'east'.
		self.grid.orientation = 3
		self.__completed = True
		
	def __entry_action_x_automatic_moving_grid_interaction_logging_r1_first(self):
		"""Entry action for state 'first'..
		"""
		#Entry action for state 'first'.
		self.timer_service.set_timer(self, 3, (5 * 1000), False)
		self.grid.wall_front = 1 if self.laser_distance.d0 < self.grid.grid_size else 0
		self.grid.wall_left = 1 if self.laser_distance.d90 < self.grid.grid_size else 0
		self.grid.wall_back = 1 if self.laser_distance.d180 < self.grid.grid_size else 0
		self.grid.wall_right = 1 if self.laser_distance.dm90 < self.grid.grid_size else 0
		
	def __entry_action_x_automatic_moving_grid_interaction_logging_r1_second(self):
		"""Entry action for state 'second'..
		"""
		#Entry action for state 'second'.
		self.timer_service.set_timer(self, 4, (1 * 1000), False)
		self.grid.update = True
		
	def __entry_action_x_automatic_moving_grid_interaction_pr(self):
		"""Entry action for state 'pr'..
		"""
		#Entry action for state 'pr'.
		self.timer_service.set_timer(self, 5, (1 * 1000), False)
		self.raise_am_gl_update_dat()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state(self):
		"""Entry action for state 'base_state'..
		"""
		#Entry action for state 'base_state'.
		self.output.speed = 0.0
		self.output.rotation = 0.0
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared(self):
		"""Entry action for state 'left_wall_disappeared'..
		"""
		#Entry action for state 'left_wall_disappeared'.
		self.raise_am_turn_left()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward(self):
		"""Entry action for state 'move_forward'..
		"""
		#Entry action for state 'move_forward'.
		self.raise_am_move_gr()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right(self):
		"""Entry action for state 'need_to_turn_right'..
		"""
		#Entry action for state 'need_to_turn_right'.
		self.raise_am_turn_right()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end(self):
		"""Entry action for state 'dead_end'..
		"""
		#Entry action for state 'dead_end'.
		self.raise_am_turn_back()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging(self):
		"""Entry action for state 'logging'..
		"""
		#Entry action for state 'logging'.
		self.raise_am_gl_log()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_prom(self):
		"""Entry action for state 'prom'..
		"""
		#Entry action for state 'prom'.
		self.raise_am_turn_left()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_turning_south(self):
		"""Entry action for state 'turning_south'..
		"""
		#Entry action for state 'turning_south'.
		self.raise_am_start_turn()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state(self):
		"""Entry action for state 'base_state'..
		"""
		#Entry action for state 'base_state'.
		self.timer_service.set_timer(self, 6, (5 * 1000), False)
		self.timer_service.set_timer(self, 7, (5 * 1000), False)
		self.raise_am_gl_update_dat()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid(self):
		"""Entry action for state 'get_data_from_grid'..
		"""
		#Entry action for state 'get_data_from_grid'.
		self.timer_service.set_timer(self, 8, (5 * 1000), False)
		self.grid.receive = True
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go(self):
		"""Entry action for state 'turn_left_and_go'..
		"""
		#Entry action for state 'turn_left_and_go'.
		self.raise_am_turn_left()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright(self):
		""".
		"""
		self.__completed = True
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go(self):
		"""Entry action for state 'turn_right_and_go'..
		"""
		#Entry action for state 'turn_right_and_go'.
		self.raise_am_turn_right()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go(self):
		"""Entry action for state 'turn_back_and_go'..
		"""
		#Entry action for state 'turn_back_and_go'.
		self.raise_am_turn_back()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go(self):
		"""Entry action for state 'go'..
		"""
		#Entry action for state 'go'.
		self.raise_am_move_gr()
		
	def __entry_action_x_automatic_moving_automatic_moving_through_maze_turning_left(self):
		"""Entry action for state 'turning_left'..
		"""
		#Entry action for state 'turning_left'.
		self.raise_am_turn_left()
		
	def __entry_action_x_automatic_moving_move_normal(self):
		"""Entry action for state 'normal'..
		"""
		#Entry action for state 'normal'.
		self.raise_am_finished_move()
		self.output.speed = 0.0
		
	def __entry_action_x_automatic_moving_move_moving_full(self):
		"""Entry action for state 'moving full'..
		"""
		#Entry action for state 'moving full'.
		self.output.speed = self.user_var.base_speed
		self.user_var.am_x_mem = self.odom.x
		self.user_var.am_y_mem = self.odom.y
		
	def __entry_action_x_automatic_moving_move_precise(self):
		"""Entry action for state 'precise'..
		"""
		#Entry action for state 'precise'.
		self.output.speed = (-(self.user_var.base_speed) / 10.0)
		
	def __entry_action_x_automatic_moving_move_precise2(self):
		"""Entry action for state 'precise2'..
		"""
		#Entry action for state 'precise2'.
		self.output.speed = (self.user_var.base_speed / 40.0)
		
	def __entry_action_x_automatic_moving_turn_high_level_normal(self):
		"""Entry action for state 'normal'..
		"""
		#Entry action for state 'normal'.
		self.output.rotation = 0.0
		
	def __entry_action_x_automatic_moving_turn_high_level_turn_left(self):
		""".
		"""
		#Entry action for state 'turnLeft'.
		self.user_var.am_angle_targ = (self.imu.yaw + 90)
		self.__completed = True
		
	def __entry_action_x_automatic_moving_turn_high_level_turn_right(self):
		""".
		"""
		#Entry action for state 'turnRight'.
		self.user_var.am_angle_targ = (self.imu.yaw - 90)
		self.__completed = True
		
	def __entry_action_x_automatic_moving_turn_high_level_turn_back(self):
		""".
		"""
		#Entry action for state 'turnBack'.
		self.user_var.am_angle_targ = (self.imu.yaw + 180)
		self.__completed = True
		
	def __entry_action_x_automatic_moving_turn_high_level_processing_angle(self):
		"""Entry action for state 'processingAngle'..
		"""
		#Entry action for state 'processingAngle'.
		self.timer_service.set_timer(self, 9, (1 * 1000), False)
		
	def __entry_action_x_automatic_moving_turn_high_level_plus(self):
		""".
		"""
		#Entry action for state 'plus'.
		self.user_var.am_angle_targ = self.user_var.am_angle_targ + 360
		self.__completed = True
		
	def __entry_action_x_automatic_moving_turn_high_level_minus(self):
		""".
		"""
		#Entry action for state 'minus'.
		self.user_var.am_angle_targ = self.user_var.am_angle_targ - 360
		self.__completed = True
		
	def __entry_action_x_automatic_moving_turn_high_level_processing_angle2(self):
		"""Entry action for state 'processingAngle2'..
		"""
		#Entry action for state 'processingAngle2'.
		self.raise_am_start_turn()
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position(self):
		"""Entry action for state 'get_to_initial_position'..
		"""
		#Entry action for state 'get_to_initial_position'.
		self.output.rotation = self.user_var.base_rotation
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step(self):
		"""Entry action for state 'first_step'..
		"""
		#Entry action for state 'first_step'.
		self.output.rotation = (self.user_var.base_rotation * (-(1.0)))
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step(self):
		"""Entry action for state 'second_step'..
		"""
		#Entry action for state 'second_step'.
		self.output.rotation = (self.user_var.base_rotation / 10.0)
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step(self):
		"""Entry action for state 'third_step'..
		"""
		#Entry action for state 'third_step'.
		self.output.rotation = ((self.user_var.base_rotation * (-(1.0))) / 100.0)
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position(self):
		"""Entry action for state 'get_to_initial_position'..
		"""
		#Entry action for state 'get_to_initial_position'.
		self.output.rotation = self.user_var.base_rotation
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step(self):
		"""Entry action for state 'first_step'..
		"""
		#Entry action for state 'first_step'.
		self.output.rotation = self.user_var.base_rotation
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step(self):
		"""Entry action for state 'second_step'..
		"""
		#Entry action for state 'second_step'.
		self.output.rotation = ((self.user_var.base_rotation / 10.0) * (-(1.0)))
		
	def __entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step(self):
		"""Entry action for state 'third_step'..
		"""
		#Entry action for state 'third_step'.
		self.output.rotation = (self.user_var.base_rotation / 100.0)
		
	def __entry_action_x_automatic_moving_turn_low_level_finished_turn(self):
		""".
		"""
		#Entry action for state 'finished_turn'.
		self.output.rotation = 0.0
		self.raise_am_finished_turn()
		self.__completed = True
		
	def __entry_action_x_calibration(self):
		"""Entry action for state 'calibration'..
		"""
		#Entry action for state 'calibration'.
		self.user_var.is_calibrated = True
		
	def __entry_action_x_calibration_calibration_calibrate(self):
		""".
		"""
		#Entry action for state 'calibrate'.
		self.start_pos.set_zero = True
		self.start_pos.zero_x = self.odom.x
		self.start_pos.zero_y = self.odom.y
		self.start_pos.zero_south_degree = self.imu.yaw
		self.__completed = True
		
	def __entry_action_x_calibration_calibration_maze_orientation(self):
		""".
		"""
		#Entry action for state 'maze_orientation'.
		self.user_var.maze_orientation = 0 if (((self.start_pos.zero_south_degree < 10) and (self.start_pos.zero_south_degree > -(10))) or (self.start_pos.zero_south_degree > 170) or (self.start_pos.zero_south_degree < -(170))) else 1
		self.__completed = True
		
	def __exit_action_x_automatic_moving_row_calcualtion_calc(self):
		"""Exit action for state 'calc'..
		"""
		#Exit action for state 'calc'.
		self.timer_service.unset_timer(self, 0)
		
	def __exit_action_x_automatic_moving_column_calculation_calc(self):
		"""Exit action for state 'calc'..
		"""
		#Exit action for state 'calc'.
		self.timer_service.unset_timer(self, 1)
		
	def __exit_action_x_automatic_moving_direction_calculation_calc(self):
		"""Exit action for state 'calc'..
		"""
		#Exit action for state 'calc'.
		self.timer_service.unset_timer(self, 2)
		
	def __exit_action_x_automatic_moving_grid_interaction_logging_r1_first(self):
		"""Exit action for state 'first'..
		"""
		#Exit action for state 'first'.
		self.timer_service.unset_timer(self, 3)
		
	def __exit_action_x_automatic_moving_grid_interaction_logging_r1_second(self):
		"""Exit action for state 'second'..
		"""
		#Exit action for state 'second'.
		self.timer_service.unset_timer(self, 4)
		
	def __exit_action_x_automatic_moving_grid_interaction_pr(self):
		"""Exit action for state 'pr'..
		"""
		#Exit action for state 'pr'.
		self.timer_service.unset_timer(self, 5)
		
	def __exit_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state(self):
		"""Exit action for state 'base_state'..
		"""
		#Exit action for state 'base_state'.
		self.timer_service.unset_timer(self, 6)
		self.timer_service.unset_timer(self, 7)
		
	def __exit_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid(self):
		"""Exit action for state 'get_data_from_grid'..
		"""
		#Exit action for state 'get_data_from_grid'.
		self.timer_service.unset_timer(self, 8)
		
	def __exit_action_x_automatic_moving_turn_high_level_processing_angle(self):
		"""Exit action for state 'processingAngle'..
		"""
		#Exit action for state 'processingAngle'.
		self.timer_service.unset_timer(self, 9)
		
	def __enter_sequence_x_manual_control_default(self):
		"""'default' enter sequence for state Manual Control.
		"""
		#'default' enter sequence for state Manual Control
		self.__enter_sequence_x_manual_control_manual_control_region_default()
		
	def __enter_sequence_x_manual_control_manual_control_region_idle_default(self):
		"""'default' enter sequence for state Idle.
		"""
		#'default' enter sequence for state Idle
		self.__entry_action_x_manual_control_manual_control_region_idle()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_idle
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_decreasing_speed_default(self):
		"""'default' enter sequence for state Decreasing speed.
		"""
		#'default' enter sequence for state Decreasing speed
		self.__entry_action_x_manual_control_manual_control_region_decreasing_speed()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_decreasing_speed
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_increasing_speed_default(self):
		"""'default' enter sequence for state Increasing speed.
		"""
		#'default' enter sequence for state Increasing speed
		self.__entry_action_x_manual_control_manual_control_region_increasing_speed()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_increasing_speed
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_turning_right_default(self):
		"""'default' enter sequence for state Turning right.
		"""
		#'default' enter sequence for state Turning right
		self.__entry_action_x_manual_control_manual_control_region_turning_right()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_turning_right
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_turning_left_default(self):
		"""'default' enter sequence for state Turning left.
		"""
		#'default' enter sequence for state Turning left
		self.__entry_action_x_manual_control_manual_control_region_turning_left()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_turning_left
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_default(self):
		"""'default' enter sequence for state automatic moving.
		"""
		#'default' enter sequence for state automatic moving
		self.__enter_sequence_x_automatic_moving_row_calcualtion_default()
		self.__enter_sequence_x_automatic_moving_column_calculation_default()
		self.__enter_sequence_x_automatic_moving_direction_calculation_default()
		self.__enter_sequence_x_automatic_moving_grid_interaction_default()
		self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_default()
		self.__enter_sequence_x_automatic_moving_move_default()
		self.__enter_sequence_x_automatic_moving_turn_high_level_default()
		self.__enter_sequence_x_automatic_moving_turn_low_level_default()
		
	def __enter_sequence_x_automatic_moving_row_calcualtion_base_state_default(self):
		"""'default' enter sequence for state base_state.
		"""
		#'default' enter sequence for state base_state
		self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_base_state
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_row_calcualtion_calc_default(self):
		"""'default' enter sequence for state calc.
		"""
		#'default' enter sequence for state calc
		self.__entry_action_x_automatic_moving_row_calcualtion_calc()
		self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_calc
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_row_calcualtion_zero_default(self):
		"""'default' enter sequence for state zero.
		"""
		#'default' enter sequence for state zero
		self.__entry_action_x_automatic_moving_row_calcualtion_zero()
		self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_zero
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_row_calcualtion_one_default(self):
		"""'default' enter sequence for state one.
		"""
		#'default' enter sequence for state one
		self.__entry_action_x_automatic_moving_row_calcualtion_one()
		self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_one
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_row_calcualtion_two_default(self):
		"""'default' enter sequence for state two.
		"""
		#'default' enter sequence for state two
		self.__entry_action_x_automatic_moving_row_calcualtion_two()
		self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_two
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_row_calcualtion_three_default(self):
		"""'default' enter sequence for state three.
		"""
		#'default' enter sequence for state three
		self.__entry_action_x_automatic_moving_row_calcualtion_three()
		self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_three
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_column_calculation_base_state_default(self):
		"""'default' enter sequence for state base state.
		"""
		#'default' enter sequence for state base state
		self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_base_state
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_column_calculation_calc_default(self):
		"""'default' enter sequence for state calc.
		"""
		#'default' enter sequence for state calc
		self.__entry_action_x_automatic_moving_column_calculation_calc()
		self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_calc
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_column_calculation_zero_default(self):
		"""'default' enter sequence for state zero.
		"""
		#'default' enter sequence for state zero
		self.__entry_action_x_automatic_moving_column_calculation_zero()
		self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_zero
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_column_calculation_one_default(self):
		"""'default' enter sequence for state one.
		"""
		#'default' enter sequence for state one
		self.__entry_action_x_automatic_moving_column_calculation_one()
		self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_one
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_column_calculation_two_default(self):
		"""'default' enter sequence for state two.
		"""
		#'default' enter sequence for state two
		self.__entry_action_x_automatic_moving_column_calculation_two()
		self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_two
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_column_calculation_three_default(self):
		"""'default' enter sequence for state three.
		"""
		#'default' enter sequence for state three
		self.__entry_action_x_automatic_moving_column_calculation_three()
		self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_three
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_direction_calculation_calc_default(self):
		"""'default' enter sequence for state calc.
		"""
		#'default' enter sequence for state calc
		self.__entry_action_x_automatic_moving_direction_calculation_calc()
		self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_calc
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_direction_calculation_north_default(self):
		"""'default' enter sequence for state north.
		"""
		#'default' enter sequence for state north
		self.__entry_action_x_automatic_moving_direction_calculation_north()
		self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_north
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_direction_calculation_south_default(self):
		"""'default' enter sequence for state south.
		"""
		#'default' enter sequence for state south
		self.__entry_action_x_automatic_moving_direction_calculation_south()
		self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_south
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_direction_calculation_west_default(self):
		"""'default' enter sequence for state west.
		"""
		#'default' enter sequence for state west
		self.__entry_action_x_automatic_moving_direction_calculation_west()
		self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_west
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_direction_calculation_east_default(self):
		"""'default' enter sequence for state east.
		"""
		#'default' enter sequence for state east
		self.__entry_action_x_automatic_moving_direction_calculation_east()
		self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_east
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_direction_calculation_base_default(self):
		"""'default' enter sequence for state base.
		"""
		#'default' enter sequence for state base
		self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_base
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_grid_interaction_unlogging_default(self):
		"""'default' enter sequence for state unlogging.
		"""
		#'default' enter sequence for state unlogging
		self.__state_vector[3] = self.State.xautomatic_moving_grid_interaction_unlogging
		self.__state_conf_vector_position = 3
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_grid_interaction_logging_default(self):
		"""'default' enter sequence for state logging.
		"""
		#'default' enter sequence for state logging
		self.__enter_sequence_x_automatic_moving_grid_interaction_logging_r1_default()
		
	def __enter_sequence_x_automatic_moving_grid_interaction_logging_r1_first_default(self):
		"""'default' enter sequence for state first.
		"""
		#'default' enter sequence for state first
		self.__entry_action_x_automatic_moving_grid_interaction_logging_r1_first()
		self.__state_vector[3] = self.State.xautomatic_moving_grid_interaction_logging_r1first
		self.__state_conf_vector_position = 3
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_grid_interaction_logging_r1_second_default(self):
		"""'default' enter sequence for state second.
		"""
		#'default' enter sequence for state second
		self.__entry_action_x_automatic_moving_grid_interaction_logging_r1_second()
		self.__state_vector[3] = self.State.xautomatic_moving_grid_interaction_logging_r1second
		self.__state_conf_vector_position = 3
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_grid_interaction_pr_default(self):
		"""'default' enter sequence for state pr.
		"""
		#'default' enter sequence for state pr
		self.__entry_action_x_automatic_moving_grid_interaction_pr()
		self.__state_vector[3] = self.State.xautomatic_moving_grid_interaction_pr
		self.__state_conf_vector_position = 3
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_default(self):
		"""'default' enter sequence for state moving with lidar.
		"""
		#'default' enter sequence for state moving with lidar
		self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_default()
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state_default(self):
		"""'default' enter sequence for state base_state.
		"""
		#'default' enter sequence for state base_state
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_default(self):
		"""'default' enter sequence for state left_wall_disappeared.
		"""
		#'default' enter sequence for state left_wall_disappeared
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_default(self):
		"""'default' enter sequence for state wall_in_front.
		"""
		#'default' enter sequence for state wall_in_front
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_default(self):
		"""'default' enter sequence for state move_forward.
		"""
		#'default' enter sequence for state move_forward
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right_default(self):
		"""'default' enter sequence for state need_to_turn_right.
		"""
		#'default' enter sequence for state need_to_turn_right
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end_default(self):
		"""'default' enter sequence for state dead_end.
		"""
		#'default' enter sequence for state dead_end
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging_default(self):
		"""'default' enter sequence for state logging.
		"""
		#'default' enter sequence for state logging
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell_default(self):
		"""'default' enter sequence for state returned_to_initial_cell.
		"""
		#'default' enter sequence for state returned_to_initial_cell
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_prom_default(self):
		"""'default' enter sequence for state prom.
		"""
		#'default' enter sequence for state prom
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_prom()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_prom
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_turning_south_default(self):
		"""'default' enter sequence for state turning_south.
		"""
		#'default' enter sequence for state turning_south
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_turning_south()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_turning_south
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_default(self):
		"""'default' enter sequence for state moving_withoout_lidar.
		"""
		#'default' enter sequence for state moving_withoout_lidar
		self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_default()
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state_default(self):
		"""'default' enter sequence for state base_state.
		"""
		#'default' enter sequence for state base_state
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid_default(self):
		"""'default' enter sequence for state get_data_from_grid.
		"""
		#'default' enter sequence for state get_data_from_grid
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision_default(self):
		"""'default' enter sequence for state start_decision.
		"""
		#'default' enter sequence for state start_decision
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go_default(self):
		"""'default' enter sequence for state turn_left_and_go.
		"""
		#'default' enter sequence for state turn_left_and_go
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright_default(self):
		"""'default' enter sequence for state go_stright.
		"""
		#'default' enter sequence for state go_stright
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go_default(self):
		"""'default' enter sequence for state turn_right_and_go.
		"""
		#'default' enter sequence for state turn_right_and_go
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go_default(self):
		"""'default' enter sequence for state turn_back_and_go.
		"""
		#'default' enter sequence for state turn_back_and_go
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_default(self):
		"""'default' enter sequence for state go.
		"""
		#'default' enter sequence for state go
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished_default(self):
		"""'default' enter sequence for state finished.
		"""
		#'default' enter sequence for state finished
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_turning_left_default(self):
		"""'default' enter sequence for state turning_left.
		"""
		#'default' enter sequence for state turning_left
		self.__entry_action_x_automatic_moving_automatic_moving_through_maze_turning_left()
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_turning_left
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_move_normal_default(self):
		"""'default' enter sequence for state normal.
		"""
		#'default' enter sequence for state normal
		self.__entry_action_x_automatic_moving_move_normal()
		self.__state_vector[5] = self.State.xautomatic_moving_move_normal
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_move_moving_full_default(self):
		"""'default' enter sequence for state moving full.
		"""
		#'default' enter sequence for state moving full
		self.__entry_action_x_automatic_moving_move_moving_full()
		self.__state_vector[5] = self.State.xautomatic_moving_move_moving_full
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_move_precise_default(self):
		"""'default' enter sequence for state precise.
		"""
		#'default' enter sequence for state precise
		self.__entry_action_x_automatic_moving_move_precise()
		self.__state_vector[5] = self.State.xautomatic_moving_move_precise
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_move_precise2_default(self):
		"""'default' enter sequence for state precise2.
		"""
		#'default' enter sequence for state precise2
		self.__entry_action_x_automatic_moving_move_precise2()
		self.__state_vector[5] = self.State.xautomatic_moving_move_precise2
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_high_level_normal_default(self):
		"""'default' enter sequence for state normal.
		"""
		#'default' enter sequence for state normal
		self.__entry_action_x_automatic_moving_turn_high_level_normal()
		self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_normal
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_high_level_turn_left_default(self):
		"""'default' enter sequence for state turnLeft.
		"""
		#'default' enter sequence for state turnLeft
		self.__entry_action_x_automatic_moving_turn_high_level_turn_left()
		self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_turn_left
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_high_level_turn_right_default(self):
		"""'default' enter sequence for state turnRight.
		"""
		#'default' enter sequence for state turnRight
		self.__entry_action_x_automatic_moving_turn_high_level_turn_right()
		self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_turn_right
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_high_level_turn_back_default(self):
		"""'default' enter sequence for state turnBack.
		"""
		#'default' enter sequence for state turnBack
		self.__entry_action_x_automatic_moving_turn_high_level_turn_back()
		self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_turn_back
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_high_level_plus_default(self):
		"""'default' enter sequence for state plus.
		"""
		#'default' enter sequence for state plus
		self.__entry_action_x_automatic_moving_turn_high_level_plus()
		self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_plus
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_high_level_minus_default(self):
		"""'default' enter sequence for state minus.
		"""
		#'default' enter sequence for state minus
		self.__entry_action_x_automatic_moving_turn_high_level_minus()
		self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_minus
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_high_level_processing_angle2_default(self):
		"""'default' enter sequence for state processingAngle2.
		"""
		#'default' enter sequence for state processingAngle2
		self.__entry_action_x_automatic_moving_turn_high_level_processing_angle2()
		self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_processing_angle2
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_base_state_default(self):
		"""'default' enter sequence for state base_state.
		"""
		#'default' enter sequence for state base_state
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_base_state
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_default(self):
		"""'default' enter sequence for state turn_to_negative_angle.
		"""
		#'default' enter sequence for state turn_to_negative_angle
		self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_default()
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position_default(self):
		"""'default' enter sequence for state get_to_initial_position.
		"""
		#'default' enter sequence for state get_to_initial_position
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step_default(self):
		"""'default' enter sequence for state first_step.
		"""
		#'default' enter sequence for state first_step
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step_default(self):
		"""'default' enter sequence for state second_step.
		"""
		#'default' enter sequence for state second_step
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step_default(self):
		"""'default' enter sequence for state third_step.
		"""
		#'default' enter sequence for state third_step
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_default(self):
		"""'default' enter sequence for state turn_to_positive_angle.
		"""
		#'default' enter sequence for state turn_to_positive_angle
		self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_default()
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position_default(self):
		"""'default' enter sequence for state get_to_initial_position.
		"""
		#'default' enter sequence for state get_to_initial_position
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step_default(self):
		"""'default' enter sequence for state first_step.
		"""
		#'default' enter sequence for state first_step
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step_default(self):
		"""'default' enter sequence for state second_step.
		"""
		#'default' enter sequence for state second_step
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step_default(self):
		"""'default' enter sequence for state third_step.
		"""
		#'default' enter sequence for state third_step
		self.__entry_action_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_turn_low_level_finished_turn_default(self):
		"""'default' enter sequence for state finished_turn.
		"""
		#'default' enter sequence for state finished_turn
		self.__entry_action_x_automatic_moving_turn_low_level_finished_turn()
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_finished_turn
		self.__state_conf_vector_position = 7
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_calibration_default(self):
		"""'default' enter sequence for state calibration.
		"""
		#'default' enter sequence for state calibration
		self.__entry_action_x_calibration()
		self.__enter_sequence_x_calibration_calibration_default()
		
	def __enter_sequence_x_calibration_calibration_calibrate_default(self):
		"""'default' enter sequence for state calibrate.
		"""
		#'default' enter sequence for state calibrate
		self.__entry_action_x_calibration_calibration_calibrate()
		self.__state_vector[0] = self.State.xcalibration_calibration_calibrate
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_default(self):
		"""'default' enter sequence for region x.
		"""
		#'default' enter sequence for region x
		self.__react_x__entry_default()
		
	def __enter_sequence_x_manual_control_manual_control_region_default(self):
		"""'default' enter sequence for region manual control region.
		"""
		#'default' enter sequence for region manual control region
		self.__react_x_manual_control_manual_control_region__entry_default()
		
	def __enter_sequence_x_automatic_moving_row_calcualtion_default(self):
		"""'default' enter sequence for region row calcualtion.
		"""
		#'default' enter sequence for region row calcualtion
		self.__react_x_automatic_moving_row_calcualtion__entry_default()
		
	def __enter_sequence_x_automatic_moving_column_calculation_default(self):
		"""'default' enter sequence for region column calculation.
		"""
		#'default' enter sequence for region column calculation
		self.__react_x_automatic_moving_column_calculation__entry_default()
		
	def __enter_sequence_x_automatic_moving_direction_calculation_default(self):
		"""'default' enter sequence for region direction calculation.
		"""
		#'default' enter sequence for region direction calculation
		self.__react_x_automatic_moving_direction_calculation__entry_default()
		
	def __enter_sequence_x_automatic_moving_grid_interaction_default(self):
		"""'default' enter sequence for region grid interaction.
		"""
		#'default' enter sequence for region grid interaction
		self.__react_x_automatic_moving_grid_interaction__entry_default()
		
	def __enter_sequence_x_automatic_moving_grid_interaction_logging_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_x_automatic_moving_grid_interaction_logging_r1__entry_default()
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_default(self):
		"""'default' enter sequence for region automatic moving through maze.
		"""
		#'default' enter sequence for region automatic moving through maze
		self.__react_x_automatic_moving_automatic_moving_through_maze__entry_default()
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1__entry_default()
		
	def __enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_default(self):
		"""'default' enter sequence for region moving_withoout_lidar.
		"""
		#'default' enter sequence for region moving_withoout_lidar
		self.__react_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar__entry_default()
		
	def __enter_sequence_x_automatic_moving_move_default(self):
		"""'default' enter sequence for region move.
		"""
		#'default' enter sequence for region move
		self.__react_x_automatic_moving_move__entry_default()
		
	def __enter_sequence_x_automatic_moving_turn_high_level_default(self):
		"""'default' enter sequence for region turn high level.
		"""
		#'default' enter sequence for region turn high level
		self.__react_x_automatic_moving_turn_high_level__entry_default()
		
	def __enter_sequence_x_automatic_moving_turn_low_level_default(self):
		"""'default' enter sequence for region turn low level.
		"""
		#'default' enter sequence for region turn low level
		self.__react_x_automatic_moving_turn_low_level__entry_default()
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_default(self):
		"""'default' enter sequence for region turn_to_negative_angle.
		"""
		#'default' enter sequence for region turn_to_negative_angle
		self.__react_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle__entry_default()
		
	def __enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_default(self):
		"""'default' enter sequence for region turn_to_positive_angle.
		"""
		#'default' enter sequence for region turn_to_positive_angle
		self.__react_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle__entry_default()
		
	def __enter_sequence_x_calibration_calibration_default(self):
		"""'default' enter sequence for region calibration.
		"""
		#'default' enter sequence for region calibration
		self.__react_x_calibration_calibration__entry_default()
		
	def __exit_sequence_x_manual_control(self):
		"""Default exit sequence for state Manual Control.
		"""
		#Default exit sequence for state Manual Control
		self.__exit_sequence_x_manual_control_manual_control_region()
		self.__state_vector[0] = self.State.null_state
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_idle(self):
		"""Default exit sequence for state Idle.
		"""
		#Default exit sequence for state Idle
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_in_action(self):
		"""Default exit sequence for state In action.
		"""
		#Default exit sequence for state In action
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_decreasing_speed(self):
		"""Default exit sequence for state Decreasing speed.
		"""
		#Default exit sequence for state Decreasing speed
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_increasing_speed(self):
		"""Default exit sequence for state Increasing speed.
		"""
		#Default exit sequence for state Increasing speed
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_turning_right(self):
		"""Default exit sequence for state Turning right.
		"""
		#Default exit sequence for state Turning right
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_turning_left(self):
		"""Default exit sequence for state Turning left.
		"""
		#Default exit sequence for state Turning left
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving(self):
		"""Default exit sequence for state automatic moving.
		"""
		#Default exit sequence for state automatic moving
		self.__exit_sequence_x_automatic_moving_row_calcualtion()
		self.__exit_sequence_x_automatic_moving_column_calculation()
		self.__exit_sequence_x_automatic_moving_direction_calculation()
		self.__exit_sequence_x_automatic_moving_grid_interaction()
		self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze()
		self.__exit_sequence_x_automatic_moving_move()
		self.__exit_sequence_x_automatic_moving_turn_high_level()
		self.__exit_sequence_x_automatic_moving_turn_low_level()
		self.__state_vector[0] = self.State.null_state
		self.__state_vector[1] = self.State.null_state
		self.__state_vector[2] = self.State.null_state
		self.__state_vector[3] = self.State.null_state
		self.__state_vector[4] = self.State.null_state
		self.__state_vector[5] = self.State.null_state
		self.__state_vector[6] = self.State.null_state
		self.__state_vector[7] = self.State.null_state
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_row_calcualtion_base_state(self):
		"""Default exit sequence for state base_state.
		"""
		#Default exit sequence for state base_state
		self.__state_vector[0] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_row_calcualtion_calc(self):
		"""Default exit sequence for state calc.
		"""
		#Default exit sequence for state calc
		self.__state_vector[0] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 0
		self.__exit_action_x_automatic_moving_row_calcualtion_calc()
		
	def __exit_sequence_x_automatic_moving_row_calcualtion_zero(self):
		"""Default exit sequence for state zero.
		"""
		#Default exit sequence for state zero
		self.__state_vector[0] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_row_calcualtion_one(self):
		"""Default exit sequence for state one.
		"""
		#Default exit sequence for state one
		self.__state_vector[0] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_row_calcualtion_two(self):
		"""Default exit sequence for state two.
		"""
		#Default exit sequence for state two
		self.__state_vector[0] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_row_calcualtion_three(self):
		"""Default exit sequence for state three.
		"""
		#Default exit sequence for state three
		self.__state_vector[0] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_column_calculation_base_state(self):
		"""Default exit sequence for state base state.
		"""
		#Default exit sequence for state base state
		self.__state_vector[1] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_column_calculation_calc(self):
		"""Default exit sequence for state calc.
		"""
		#Default exit sequence for state calc
		self.__state_vector[1] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 1
		self.__exit_action_x_automatic_moving_column_calculation_calc()
		
	def __exit_sequence_x_automatic_moving_column_calculation_zero(self):
		"""Default exit sequence for state zero.
		"""
		#Default exit sequence for state zero
		self.__state_vector[1] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_column_calculation_one(self):
		"""Default exit sequence for state one.
		"""
		#Default exit sequence for state one
		self.__state_vector[1] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_column_calculation_two(self):
		"""Default exit sequence for state two.
		"""
		#Default exit sequence for state two
		self.__state_vector[1] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_column_calculation_three(self):
		"""Default exit sequence for state three.
		"""
		#Default exit sequence for state three
		self.__state_vector[1] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_direction_calculation_calc(self):
		"""Default exit sequence for state calc.
		"""
		#Default exit sequence for state calc
		self.__state_vector[2] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 2
		self.__exit_action_x_automatic_moving_direction_calculation_calc()
		
	def __exit_sequence_x_automatic_moving_direction_calculation_north(self):
		"""Default exit sequence for state north.
		"""
		#Default exit sequence for state north
		self.__state_vector[2] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 2
		
	def __exit_sequence_x_automatic_moving_direction_calculation_south(self):
		"""Default exit sequence for state south.
		"""
		#Default exit sequence for state south
		self.__state_vector[2] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 2
		
	def __exit_sequence_x_automatic_moving_direction_calculation_west(self):
		"""Default exit sequence for state west.
		"""
		#Default exit sequence for state west
		self.__state_vector[2] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 2
		
	def __exit_sequence_x_automatic_moving_direction_calculation_east(self):
		"""Default exit sequence for state east.
		"""
		#Default exit sequence for state east
		self.__state_vector[2] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 2
		
	def __exit_sequence_x_automatic_moving_direction_calculation_base(self):
		"""Default exit sequence for state base.
		"""
		#Default exit sequence for state base
		self.__state_vector[2] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 2
		
	def __exit_sequence_x_automatic_moving_grid_interaction_unlogging(self):
		"""Default exit sequence for state unlogging.
		"""
		#Default exit sequence for state unlogging
		self.__state_vector[3] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 3
		
	def __exit_sequence_x_automatic_moving_grid_interaction_logging(self):
		"""Default exit sequence for state logging.
		"""
		#Default exit sequence for state logging
		self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1()
		self.__state_vector[3] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 3
		
	def __exit_sequence_x_automatic_moving_grid_interaction_logging_r1_first(self):
		"""Default exit sequence for state first.
		"""
		#Default exit sequence for state first
		self.__state_vector[3] = self.State.xautomatic_moving_grid_interaction_logging
		self.__state_conf_vector_position = 3
		self.__exit_action_x_automatic_moving_grid_interaction_logging_r1_first()
		
	def __exit_sequence_x_automatic_moving_grid_interaction_logging_r1_second(self):
		"""Default exit sequence for state second.
		"""
		#Default exit sequence for state second
		self.__state_vector[3] = self.State.xautomatic_moving_grid_interaction_logging
		self.__state_conf_vector_position = 3
		self.__exit_action_x_automatic_moving_grid_interaction_logging_r1_second()
		
	def __exit_sequence_x_automatic_moving_grid_interaction_pr(self):
		"""Default exit sequence for state pr.
		"""
		#Default exit sequence for state pr
		self.__state_vector[3] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 3
		self.__exit_action_x_automatic_moving_grid_interaction_pr()
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar(self):
		"""Default exit sequence for state moving with lidar.
		"""
		#Default exit sequence for state moving with lidar
		self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1()
		self.__state_vector[4] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state(self):
		"""Default exit sequence for state base_state.
		"""
		#Default exit sequence for state base_state
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared(self):
		"""Default exit sequence for state left_wall_disappeared.
		"""
		#Default exit sequence for state left_wall_disappeared
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front(self):
		"""Default exit sequence for state wall_in_front.
		"""
		#Default exit sequence for state wall_in_front
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward(self):
		"""Default exit sequence for state move_forward.
		"""
		#Default exit sequence for state move_forward
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right(self):
		"""Default exit sequence for state need_to_turn_right.
		"""
		#Default exit sequence for state need_to_turn_right
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end(self):
		"""Default exit sequence for state dead_end.
		"""
		#Default exit sequence for state dead_end
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging(self):
		"""Default exit sequence for state logging.
		"""
		#Default exit sequence for state logging
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell(self):
		"""Default exit sequence for state returned_to_initial_cell.
		"""
		#Default exit sequence for state returned_to_initial_cell
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_prom(self):
		"""Default exit sequence for state prom.
		"""
		#Default exit sequence for state prom
		self.__state_vector[4] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_south(self):
		"""Default exit sequence for state turning_south.
		"""
		#Default exit sequence for state turning_south
		self.__state_vector[4] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar(self):
		"""Default exit sequence for state moving_withoout_lidar.
		"""
		#Default exit sequence for state moving_withoout_lidar
		self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar()
		self.__state_vector[4] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state(self):
		"""Default exit sequence for state base_state.
		"""
		#Default exit sequence for state base_state
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		self.__exit_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state()
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid(self):
		"""Default exit sequence for state get_data_from_grid.
		"""
		#Default exit sequence for state get_data_from_grid
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		self.__exit_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid()
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision(self):
		"""Default exit sequence for state start_decision.
		"""
		#Default exit sequence for state start_decision
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go(self):
		"""Default exit sequence for state turn_left_and_go.
		"""
		#Default exit sequence for state turn_left_and_go
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright(self):
		"""Default exit sequence for state go_stright.
		"""
		#Default exit sequence for state go_stright
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go(self):
		"""Default exit sequence for state turn_right_and_go.
		"""
		#Default exit sequence for state turn_right_and_go
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go(self):
		"""Default exit sequence for state turn_back_and_go.
		"""
		#Default exit sequence for state turn_back_and_go
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go(self):
		"""Default exit sequence for state go.
		"""
		#Default exit sequence for state go
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished(self):
		"""Default exit sequence for state finished.
		"""
		#Default exit sequence for state finished
		self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_left(self):
		"""Default exit sequence for state turning_left.
		"""
		#Default exit sequence for state turning_left
		self.__state_vector[4] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_move_normal(self):
		"""Default exit sequence for state normal.
		"""
		#Default exit sequence for state normal
		self.__state_vector[5] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_move_moving_full(self):
		"""Default exit sequence for state moving full.
		"""
		#Default exit sequence for state moving full
		self.__state_vector[5] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_move_precise(self):
		"""Default exit sequence for state precise.
		"""
		#Default exit sequence for state precise
		self.__state_vector[5] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_move_precise2(self):
		"""Default exit sequence for state precise2.
		"""
		#Default exit sequence for state precise2
		self.__state_vector[5] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_turn_high_level_normal(self):
		"""Default exit sequence for state normal.
		"""
		#Default exit sequence for state normal
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_turn_high_level_turn_left(self):
		"""Default exit sequence for state turnLeft.
		"""
		#Default exit sequence for state turnLeft
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_turn_high_level_turn_right(self):
		"""Default exit sequence for state turnRight.
		"""
		#Default exit sequence for state turnRight
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_turn_high_level_turn_back(self):
		"""Default exit sequence for state turnBack.
		"""
		#Default exit sequence for state turnBack
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_turn_high_level_processing_angle(self):
		"""Default exit sequence for state processingAngle.
		"""
		#Default exit sequence for state processingAngle
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		self.__exit_action_x_automatic_moving_turn_high_level_processing_angle()
		
	def __exit_sequence_x_automatic_moving_turn_high_level_plus(self):
		"""Default exit sequence for state plus.
		"""
		#Default exit sequence for state plus
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_turn_high_level_minus(self):
		"""Default exit sequence for state minus.
		"""
		#Default exit sequence for state minus
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_turn_high_level_processing_angle2(self):
		"""Default exit sequence for state processingAngle2.
		"""
		#Default exit sequence for state processingAngle2
		self.__state_vector[6] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_turn_low_level_base_state(self):
		"""Default exit sequence for state base_state.
		"""
		#Default exit sequence for state base_state
		self.__state_vector[7] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle(self):
		"""Default exit sequence for state turn_to_negative_angle.
		"""
		#Default exit sequence for state turn_to_negative_angle
		self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle()
		self.__state_vector[7] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position(self):
		"""Default exit sequence for state get_to_initial_position.
		"""
		#Default exit sequence for state get_to_initial_position
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step(self):
		"""Default exit sequence for state first_step.
		"""
		#Default exit sequence for state first_step
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step(self):
		"""Default exit sequence for state second_step.
		"""
		#Default exit sequence for state second_step
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step(self):
		"""Default exit sequence for state third_step.
		"""
		#Default exit sequence for state third_step
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle(self):
		"""Default exit sequence for state turn_to_positive_angle.
		"""
		#Default exit sequence for state turn_to_positive_angle
		self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle()
		self.__state_vector[7] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position(self):
		"""Default exit sequence for state get_to_initial_position.
		"""
		#Default exit sequence for state get_to_initial_position
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step(self):
		"""Default exit sequence for state first_step.
		"""
		#Default exit sequence for state first_step
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step(self):
		"""Default exit sequence for state second_step.
		"""
		#Default exit sequence for state second_step
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step(self):
		"""Default exit sequence for state third_step.
		"""
		#Default exit sequence for state third_step
		self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_automatic_moving_turn_low_level_finished_turn(self):
		"""Default exit sequence for state finished_turn.
		"""
		#Default exit sequence for state finished_turn
		self.__state_vector[7] = self.State.xautomatic_moving
		self.__state_conf_vector_position = 7
		
	def __exit_sequence_x_calibration(self):
		"""Default exit sequence for state calibration.
		"""
		#Default exit sequence for state calibration
		self.__exit_sequence_x_calibration_calibration()
		self.__state_vector[0] = self.State.null_state
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_calibration_calibration_calibrate(self):
		"""Default exit sequence for state calibrate.
		"""
		#Default exit sequence for state calibrate
		self.__state_vector[0] = self.State.xcalibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_calibration_calibration_maze_orientation(self):
		"""Default exit sequence for state maze_orientation.
		"""
		#Default exit sequence for state maze_orientation
		self.__state_vector[0] = self.State.xcalibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x(self):
		"""Default exit sequence for region x.
		"""
		#Default exit sequence for region x
		state = self.__state_vector[0]
		if state == self.State.xmanual_control:
			self.__exit_sequence_x_manual_control()
		elif state == self.State.xmanual_control_manual_control_region_idle:
			self.__exit_sequence_x_manual_control_manual_control_region_idle()
		elif state == self.State.xmanual_control_manual_control_region_in_action:
			self.__exit_sequence_x_manual_control_manual_control_region_in_action()
		elif state == self.State.xmanual_control_manual_control_region_decreasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_decreasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_increasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_increasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_turning_right:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_right()
		elif state == self.State.xmanual_control_manual_control_region_turning_left:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_left()
		elif state == self.State.xautomatic_moving_row_calcualtion_base_state:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_base_state()
		elif state == self.State.xautomatic_moving_row_calcualtion_calc:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_calc()
		elif state == self.State.xautomatic_moving_row_calcualtion_zero:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_zero()
		elif state == self.State.xautomatic_moving_row_calcualtion_one:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_one()
		elif state == self.State.xautomatic_moving_row_calcualtion_two:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_two()
		elif state == self.State.xautomatic_moving_row_calcualtion_three:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_three()
		elif state == self.State.xcalibration:
			self.__exit_sequence_x_calibration()
		elif state == self.State.xcalibration_calibration_calibrate:
			self.__exit_sequence_x_calibration_calibration_calibrate()
		elif state == self.State.xcalibration_calibration_maze_orientation:
			self.__exit_sequence_x_calibration_calibration_maze_orientation()
		state = self.__state_vector[1]
		if state == self.State.xautomatic_moving_column_calculation_base_state:
			self.__exit_sequence_x_automatic_moving_column_calculation_base_state()
		elif state == self.State.xautomatic_moving_column_calculation_calc:
			self.__exit_sequence_x_automatic_moving_column_calculation_calc()
		elif state == self.State.xautomatic_moving_column_calculation_zero:
			self.__exit_sequence_x_automatic_moving_column_calculation_zero()
		elif state == self.State.xautomatic_moving_column_calculation_one:
			self.__exit_sequence_x_automatic_moving_column_calculation_one()
		elif state == self.State.xautomatic_moving_column_calculation_two:
			self.__exit_sequence_x_automatic_moving_column_calculation_two()
		elif state == self.State.xautomatic_moving_column_calculation_three:
			self.__exit_sequence_x_automatic_moving_column_calculation_three()
		state = self.__state_vector[2]
		if state == self.State.xautomatic_moving_direction_calculation_calc:
			self.__exit_sequence_x_automatic_moving_direction_calculation_calc()
		elif state == self.State.xautomatic_moving_direction_calculation_north:
			self.__exit_sequence_x_automatic_moving_direction_calculation_north()
		elif state == self.State.xautomatic_moving_direction_calculation_south:
			self.__exit_sequence_x_automatic_moving_direction_calculation_south()
		elif state == self.State.xautomatic_moving_direction_calculation_west:
			self.__exit_sequence_x_automatic_moving_direction_calculation_west()
		elif state == self.State.xautomatic_moving_direction_calculation_east:
			self.__exit_sequence_x_automatic_moving_direction_calculation_east()
		elif state == self.State.xautomatic_moving_direction_calculation_base:
			self.__exit_sequence_x_automatic_moving_direction_calculation_base()
		state = self.__state_vector[3]
		if state == self.State.xautomatic_moving_grid_interaction_unlogging:
			self.__exit_sequence_x_automatic_moving_grid_interaction_unlogging()
		elif state == self.State.xautomatic_moving_grid_interaction_logging:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging()
		elif state == self.State.xautomatic_moving_grid_interaction_logging_r1first:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1_first()
		elif state == self.State.xautomatic_moving_grid_interaction_logging_r1second:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1_second()
		elif state == self.State.xautomatic_moving_grid_interaction_pr:
			self.__exit_sequence_x_automatic_moving_grid_interaction_pr()
		state = self.__state_vector[4]
		if state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_prom:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_prom()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_turning_south:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_south()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_turning_left:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_left()
		state = self.__state_vector[5]
		if state == self.State.xautomatic_moving_move_normal:
			self.__exit_sequence_x_automatic_moving_move_normal()
		elif state == self.State.xautomatic_moving_move_moving_full:
			self.__exit_sequence_x_automatic_moving_move_moving_full()
		elif state == self.State.xautomatic_moving_move_precise:
			self.__exit_sequence_x_automatic_moving_move_precise()
		elif state == self.State.xautomatic_moving_move_precise2:
			self.__exit_sequence_x_automatic_moving_move_precise2()
		state = self.__state_vector[6]
		if state == self.State.xautomatic_moving_turn_high_level_normal:
			self.__exit_sequence_x_automatic_moving_turn_high_level_normal()
		elif state == self.State.xautomatic_moving_turn_high_level_turn_left:
			self.__exit_sequence_x_automatic_moving_turn_high_level_turn_left()
		elif state == self.State.xautomatic_moving_turn_high_level_turn_right:
			self.__exit_sequence_x_automatic_moving_turn_high_level_turn_right()
		elif state == self.State.xautomatic_moving_turn_high_level_turn_back:
			self.__exit_sequence_x_automatic_moving_turn_high_level_turn_back()
		elif state == self.State.xautomatic_moving_turn_high_level_processing_angle:
			self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle()
		elif state == self.State.xautomatic_moving_turn_high_level_plus:
			self.__exit_sequence_x_automatic_moving_turn_high_level_plus()
		elif state == self.State.xautomatic_moving_turn_high_level_minus:
			self.__exit_sequence_x_automatic_moving_turn_high_level_minus()
		elif state == self.State.xautomatic_moving_turn_high_level_processing_angle2:
			self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle2()
		state = self.__state_vector[7]
		if state == self.State.xautomatic_moving_turn_low_level_base_state:
			self.__exit_sequence_x_automatic_moving_turn_low_level_base_state()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step()
		elif state == self.State.xautomatic_moving_turn_low_level_finished_turn:
			self.__exit_sequence_x_automatic_moving_turn_low_level_finished_turn()
		
	def __exit_sequence_x_manual_control_manual_control_region(self):
		"""Default exit sequence for region manual control region.
		"""
		#Default exit sequence for region manual control region
		state = self.__state_vector[0]
		if state == self.State.xmanual_control_manual_control_region_idle:
			self.__exit_sequence_x_manual_control_manual_control_region_idle()
		elif state == self.State.xmanual_control_manual_control_region_in_action:
			self.__exit_sequence_x_manual_control_manual_control_region_in_action()
		elif state == self.State.xmanual_control_manual_control_region_decreasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_decreasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_increasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_increasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_turning_right:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_right()
		elif state == self.State.xmanual_control_manual_control_region_turning_left:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_left()
		
	def __exit_sequence_x_automatic_moving_row_calcualtion(self):
		"""Default exit sequence for region row calcualtion.
		"""
		#Default exit sequence for region row calcualtion
		state = self.__state_vector[0]
		if state == self.State.xautomatic_moving_row_calcualtion_base_state:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_base_state()
		elif state == self.State.xautomatic_moving_row_calcualtion_calc:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_calc()
		elif state == self.State.xautomatic_moving_row_calcualtion_zero:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_zero()
		elif state == self.State.xautomatic_moving_row_calcualtion_one:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_one()
		elif state == self.State.xautomatic_moving_row_calcualtion_two:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_two()
		elif state == self.State.xautomatic_moving_row_calcualtion_three:
			self.__exit_sequence_x_automatic_moving_row_calcualtion_three()
		
	def __exit_sequence_x_automatic_moving_column_calculation(self):
		"""Default exit sequence for region column calculation.
		"""
		#Default exit sequence for region column calculation
		state = self.__state_vector[1]
		if state == self.State.xautomatic_moving_column_calculation_base_state:
			self.__exit_sequence_x_automatic_moving_column_calculation_base_state()
		elif state == self.State.xautomatic_moving_column_calculation_calc:
			self.__exit_sequence_x_automatic_moving_column_calculation_calc()
		elif state == self.State.xautomatic_moving_column_calculation_zero:
			self.__exit_sequence_x_automatic_moving_column_calculation_zero()
		elif state == self.State.xautomatic_moving_column_calculation_one:
			self.__exit_sequence_x_automatic_moving_column_calculation_one()
		elif state == self.State.xautomatic_moving_column_calculation_two:
			self.__exit_sequence_x_automatic_moving_column_calculation_two()
		elif state == self.State.xautomatic_moving_column_calculation_three:
			self.__exit_sequence_x_automatic_moving_column_calculation_three()
		
	def __exit_sequence_x_automatic_moving_direction_calculation(self):
		"""Default exit sequence for region direction calculation.
		"""
		#Default exit sequence for region direction calculation
		state = self.__state_vector[2]
		if state == self.State.xautomatic_moving_direction_calculation_calc:
			self.__exit_sequence_x_automatic_moving_direction_calculation_calc()
		elif state == self.State.xautomatic_moving_direction_calculation_north:
			self.__exit_sequence_x_automatic_moving_direction_calculation_north()
		elif state == self.State.xautomatic_moving_direction_calculation_south:
			self.__exit_sequence_x_automatic_moving_direction_calculation_south()
		elif state == self.State.xautomatic_moving_direction_calculation_west:
			self.__exit_sequence_x_automatic_moving_direction_calculation_west()
		elif state == self.State.xautomatic_moving_direction_calculation_east:
			self.__exit_sequence_x_automatic_moving_direction_calculation_east()
		elif state == self.State.xautomatic_moving_direction_calculation_base:
			self.__exit_sequence_x_automatic_moving_direction_calculation_base()
		
	def __exit_sequence_x_automatic_moving_grid_interaction(self):
		"""Default exit sequence for region grid interaction.
		"""
		#Default exit sequence for region grid interaction
		state = self.__state_vector[3]
		if state == self.State.xautomatic_moving_grid_interaction_unlogging:
			self.__exit_sequence_x_automatic_moving_grid_interaction_unlogging()
		elif state == self.State.xautomatic_moving_grid_interaction_logging:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging()
		elif state == self.State.xautomatic_moving_grid_interaction_logging_r1first:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1_first()
		elif state == self.State.xautomatic_moving_grid_interaction_logging_r1second:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1_second()
		elif state == self.State.xautomatic_moving_grid_interaction_pr:
			self.__exit_sequence_x_automatic_moving_grid_interaction_pr()
		
	def __exit_sequence_x_automatic_moving_grid_interaction_logging_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[3]
		if state == self.State.xautomatic_moving_grid_interaction_logging_r1first:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1_first()
		elif state == self.State.xautomatic_moving_grid_interaction_logging_r1second:
			self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1_second()
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze(self):
		"""Default exit sequence for region automatic moving through maze.
		"""
		#Default exit sequence for region automatic moving through maze
		state = self.__state_vector[4]
		if state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_prom:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_prom()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_turning_south:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_south()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_turning_left:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_left()
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[4]
		if state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell()
		
	def __exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar(self):
		"""Default exit sequence for region moving_withoout_lidar.
		"""
		#Default exit sequence for region moving_withoout_lidar
		state = self.__state_vector[4]
		if state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go()
		elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished:
			self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished()
		
	def __exit_sequence_x_automatic_moving_move(self):
		"""Default exit sequence for region move.
		"""
		#Default exit sequence for region move
		state = self.__state_vector[5]
		if state == self.State.xautomatic_moving_move_normal:
			self.__exit_sequence_x_automatic_moving_move_normal()
		elif state == self.State.xautomatic_moving_move_moving_full:
			self.__exit_sequence_x_automatic_moving_move_moving_full()
		elif state == self.State.xautomatic_moving_move_precise:
			self.__exit_sequence_x_automatic_moving_move_precise()
		elif state == self.State.xautomatic_moving_move_precise2:
			self.__exit_sequence_x_automatic_moving_move_precise2()
		
	def __exit_sequence_x_automatic_moving_turn_high_level(self):
		"""Default exit sequence for region turn high level.
		"""
		#Default exit sequence for region turn high level
		state = self.__state_vector[6]
		if state == self.State.xautomatic_moving_turn_high_level_normal:
			self.__exit_sequence_x_automatic_moving_turn_high_level_normal()
		elif state == self.State.xautomatic_moving_turn_high_level_turn_left:
			self.__exit_sequence_x_automatic_moving_turn_high_level_turn_left()
		elif state == self.State.xautomatic_moving_turn_high_level_turn_right:
			self.__exit_sequence_x_automatic_moving_turn_high_level_turn_right()
		elif state == self.State.xautomatic_moving_turn_high_level_turn_back:
			self.__exit_sequence_x_automatic_moving_turn_high_level_turn_back()
		elif state == self.State.xautomatic_moving_turn_high_level_processing_angle:
			self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle()
		elif state == self.State.xautomatic_moving_turn_high_level_plus:
			self.__exit_sequence_x_automatic_moving_turn_high_level_plus()
		elif state == self.State.xautomatic_moving_turn_high_level_minus:
			self.__exit_sequence_x_automatic_moving_turn_high_level_minus()
		elif state == self.State.xautomatic_moving_turn_high_level_processing_angle2:
			self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle2()
		
	def __exit_sequence_x_automatic_moving_turn_low_level(self):
		"""Default exit sequence for region turn low level.
		"""
		#Default exit sequence for region turn low level
		state = self.__state_vector[7]
		if state == self.State.xautomatic_moving_turn_low_level_base_state:
			self.__exit_sequence_x_automatic_moving_turn_low_level_base_state()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step()
		elif state == self.State.xautomatic_moving_turn_low_level_finished_turn:
			self.__exit_sequence_x_automatic_moving_turn_low_level_finished_turn()
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle(self):
		"""Default exit sequence for region turn_to_negative_angle.
		"""
		#Default exit sequence for region turn_to_negative_angle
		state = self.__state_vector[7]
		if state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step()
		
	def __exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle(self):
		"""Default exit sequence for region turn_to_positive_angle.
		"""
		#Default exit sequence for region turn_to_positive_angle
		state = self.__state_vector[7]
		if state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step()
		elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step:
			self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step()
		
	def __exit_sequence_x_calibration_calibration(self):
		"""Default exit sequence for region calibration.
		"""
		#Default exit sequence for region calibration
		state = self.__state_vector[0]
		if state == self.State.xcalibration_calibration_calibrate:
			self.__exit_sequence_x_calibration_calibration_calibrate()
		elif state == self.State.xcalibration_calibration_maze_orientation:
			self.__exit_sequence_x_calibration_calibration_maze_orientation()
		
	def __react_x_manual_control_manual_control_region__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_manual_control_manual_control_region_idle_default()
		
	def __react_x__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_manual_control_default()
		
	def __react_x_automatic_moving_row_calcualtion__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_row_calcualtion_base_state_default()
		
	def __react_x_automatic_moving_column_calculation__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_column_calculation_base_state_default()
		
	def __react_x_automatic_moving_direction_calculation__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_direction_calculation_base_default()
		
	def __react_x_automatic_moving_grid_interaction__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_grid_interaction_unlogging_default()
		
	def __react_x_automatic_moving_grid_interaction_logging_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_grid_interaction_logging_r1_first_default()
		
	def __react_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state_default()
		
	def __react_x_automatic_moving_automatic_moving_through_maze__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_prom_default()
		
	def __react_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state_default()
		
	def __react_x_automatic_moving_move__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_move_normal_default()
		
	def __react_x_automatic_moving_turn_high_level__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_turn_high_level_normal_default()
		
	def __react_x_automatic_moving_turn_low_level__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_turn_low_level_base_state_default()
		
	def __react_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position_default()
		
	def __react_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position_default()
		
	def __react_x_calibration_calibration__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_calibration_calibration_calibrate_default()
		
	def __react(self, transitioned_before):
		"""Implementation of __react function.
		"""
		#State machine reactions.
		return transitioned_before
	
	
	def __x_manual_control_react(self, transitioned_before):
		"""Implementation of __x_manual_control_react function.
		"""
		#The reactions of state Manual Control.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.computer.m_press) and (self.user_var.is_calibrated):
					self.__exit_sequence_x_manual_control()
					self.__enter_sequence_x_automatic_moving_default()
					self.__react(0)
					transitioned_after = 0
				elif (self.computer.m_press) and (not self.user_var.is_calibrated):
					self.__exit_sequence_x_manual_control()
					self.__enter_sequence_x_calibration_default()
					self.__react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_idle_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_idle_react function.
		"""
		#The reactions of state Idle.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.a_press:
					self.__exit_sequence_x_manual_control_manual_control_region_idle()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_left_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.d_press:
					self.__exit_sequence_x_manual_control_manual_control_region_idle()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_right_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.w_press:
					self.__exit_sequence_x_manual_control_manual_control_region_idle()
					self.__enter_sequence_x_manual_control_manual_control_region_increasing_speed_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_in_action_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_in_action_react function.
		"""
		#The reactions of state In action.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.w_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_increasing_speed_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.x_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_decreasing_speed_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.s_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_idle_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.d_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_right_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.a_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_left_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_decreasing_speed_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_decreasing_speed_react function.
		"""
		#The reactions of state Decreasing speed.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Decreasing speed
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_increasing_speed_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_increasing_speed_react function.
		"""
		#The reactions of state Increasing speed.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Increasing speed
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_turning_right_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_turning_right_react function.
		"""
		#The reactions of state Turning right.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Turning right
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_turning_left_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_turning_left_react function.
		"""
		#The reactions of state Turning left.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Turning left
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_react function.
		"""
		#The reactions of state automatic moving.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.m_press:
					self.__exit_sequence_x_automatic_moving()
					self.__enter_sequence_x_manual_control_default()
					self.__react(0)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_row_calcualtion_base_state_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_row_calcualtion_base_state_react function.
		"""
		#The reactions of state base_state.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.am_gl_update_dat:
					self.__exit_sequence_x_automatic_moving_row_calcualtion_base_state()
					self.__enter_sequence_x_automatic_moving_row_calcualtion_calc_default()
					transitioned_after = 0
		return transitioned_after
	
	
	def __x_automatic_moving_row_calcualtion_calc_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_row_calcualtion_calc_react function.
		"""
		#The reactions of state calc.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.user_var.am_gl_row_rel <= 0.5:
					self.__exit_sequence_x_automatic_moving_row_calcualtion_calc()
					self.__enter_sequence_x_automatic_moving_row_calcualtion_zero_default()
					transitioned_after = 0
				elif self.user_var.am_gl_row_rel >= 0.5 and self.user_var.am_gl_row_rel <= 1.5:
					self.__exit_sequence_x_automatic_moving_row_calcualtion_calc()
					self.__enter_sequence_x_automatic_moving_row_calcualtion_one_default()
					transitioned_after = 0
				elif self.user_var.am_gl_row_rel >= 1.5 and self.user_var.am_gl_row_rel <= 2.5:
					self.__exit_sequence_x_automatic_moving_row_calcualtion_calc()
					self.__enter_sequence_x_automatic_moving_row_calcualtion_two_default()
					transitioned_after = 0
				elif self.user_var.am_gl_row_rel >= 2.5 and self.user_var.am_gl_row_rel <= 3.5:
					self.__exit_sequence_x_automatic_moving_row_calcualtion_calc()
					self.__enter_sequence_x_automatic_moving_row_calcualtion_three_default()
					transitioned_after = 0
				elif self.__time_events[0]:
					self.__exit_sequence_x_automatic_moving_row_calcualtion_calc()
					self.__time_events[0] = False
					self.__enter_sequence_x_automatic_moving_row_calcualtion_base_state_default()
					transitioned_after = 0
		return transitioned_after
	
	
	def __x_automatic_moving_row_calcualtion_zero_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_row_calcualtion_zero_react function.
		"""
		#The reactions of state zero.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state zero
			self.__state_vector[0] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state base_state
			self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_base_state
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_row_calcualtion_one_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_row_calcualtion_one_react function.
		"""
		#The reactions of state one.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state one
			self.__state_vector[0] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state base_state
			self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_base_state
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_row_calcualtion_two_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_row_calcualtion_two_react function.
		"""
		#The reactions of state two.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state two
			self.__state_vector[0] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state base_state
			self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_base_state
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_row_calcualtion_three_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_row_calcualtion_three_react function.
		"""
		#The reactions of state three.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state three
			self.__state_vector[0] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state base_state
			self.__state_vector[0] = self.State.xautomatic_moving_row_calcualtion_base_state
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_column_calculation_base_state_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_column_calculation_base_state_react function.
		"""
		#The reactions of state base state.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.am_gl_update_dat:
					self.__exit_sequence_x_automatic_moving_column_calculation_base_state()
					self.__enter_sequence_x_automatic_moving_column_calculation_calc_default()
					transitioned_after = 1
		return transitioned_after
	
	
	def __x_automatic_moving_column_calculation_calc_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_column_calculation_calc_react function.
		"""
		#The reactions of state calc.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.user_var.am_gl_col_rel <= 0.5:
					self.__exit_sequence_x_automatic_moving_column_calculation_calc()
					self.__enter_sequence_x_automatic_moving_column_calculation_zero_default()
					transitioned_after = 1
				elif self.user_var.am_gl_col_rel >= 0.5 and self.user_var.am_gl_col_rel <= 1.5:
					self.__exit_sequence_x_automatic_moving_column_calculation_calc()
					self.__enter_sequence_x_automatic_moving_column_calculation_one_default()
					transitioned_after = 1
				elif self.user_var.am_gl_col_rel >= 1.5 and self.user_var.am_gl_col_rel <= 2.5:
					self.__exit_sequence_x_automatic_moving_column_calculation_calc()
					self.__enter_sequence_x_automatic_moving_column_calculation_two_default()
					transitioned_after = 1
				elif self.user_var.am_gl_col_rel >= 2.5 and self.user_var.am_gl_col_rel <= 3.5:
					self.__exit_sequence_x_automatic_moving_column_calculation_calc()
					self.__enter_sequence_x_automatic_moving_column_calculation_three_default()
					transitioned_after = 1
				elif self.__time_events[1]:
					self.__exit_sequence_x_automatic_moving_column_calculation_calc()
					self.__time_events[1] = False
					self.__enter_sequence_x_automatic_moving_column_calculation_base_state_default()
					transitioned_after = 1
		return transitioned_after
	
	
	def __x_automatic_moving_column_calculation_zero_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_column_calculation_zero_react function.
		"""
		#The reactions of state zero.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state zero
			self.__state_vector[1] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 1
			#'default' enter sequence for state base state
			self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_base_state
			self.__state_conf_vector_position = 1
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_column_calculation_one_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_column_calculation_one_react function.
		"""
		#The reactions of state one.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state one
			self.__state_vector[1] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 1
			#'default' enter sequence for state base state
			self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_base_state
			self.__state_conf_vector_position = 1
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_column_calculation_two_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_column_calculation_two_react function.
		"""
		#The reactions of state two.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state two
			self.__state_vector[1] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 1
			#'default' enter sequence for state base state
			self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_base_state
			self.__state_conf_vector_position = 1
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_column_calculation_three_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_column_calculation_three_react function.
		"""
		#The reactions of state three.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state three
			self.__state_vector[1] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 1
			#'default' enter sequence for state base state
			self.__state_vector[1] = self.State.xautomatic_moving_column_calculation_base_state
			self.__state_conf_vector_position = 1
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_direction_calculation_calc_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_direction_calculation_calc_react function.
		"""
		#The reactions of state calc.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 2:
				if self.user_var.am_gl_ang < 5 or self.user_var.am_gl_ang > 355:
					self.__exit_sequence_x_automatic_moving_direction_calculation_calc()
					self.__enter_sequence_x_automatic_moving_direction_calculation_south_default()
					transitioned_after = 2
				elif self.user_var.am_gl_ang > 85 and self.user_var.am_gl_ang < 95:
					self.__exit_sequence_x_automatic_moving_direction_calculation_calc()
					self.__enter_sequence_x_automatic_moving_direction_calculation_west_default()
					transitioned_after = 2
				elif self.user_var.am_gl_ang > 265 and self.user_var.am_gl_ang < 275:
					self.__exit_sequence_x_automatic_moving_direction_calculation_calc()
					self.__enter_sequence_x_automatic_moving_direction_calculation_east_default()
					transitioned_after = 2
				elif self.user_var.am_gl_ang > 175 and self.user_var.am_gl_ang < 185:
					self.__exit_sequence_x_automatic_moving_direction_calculation_calc()
					self.__enter_sequence_x_automatic_moving_direction_calculation_north_default()
					transitioned_after = 2
				elif self.__time_events[2]:
					self.__exit_sequence_x_automatic_moving_direction_calculation_calc()
					self.__time_events[2] = False
					self.__enter_sequence_x_automatic_moving_direction_calculation_base_default()
					transitioned_after = 2
		return transitioned_after
	
	
	def __x_automatic_moving_direction_calculation_north_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_direction_calculation_north_react function.
		"""
		#The reactions of state north.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state north
			self.__state_vector[2] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 2
			#'default' enter sequence for state base
			self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_base
			self.__state_conf_vector_position = 2
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_direction_calculation_south_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_direction_calculation_south_react function.
		"""
		#The reactions of state south.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state south
			self.__state_vector[2] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 2
			#'default' enter sequence for state base
			self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_base
			self.__state_conf_vector_position = 2
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_direction_calculation_west_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_direction_calculation_west_react function.
		"""
		#The reactions of state west.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state west
			self.__state_vector[2] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 2
			#'default' enter sequence for state base
			self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_base
			self.__state_conf_vector_position = 2
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_direction_calculation_east_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_direction_calculation_east_react function.
		"""
		#The reactions of state east.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state east
			self.__state_vector[2] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 2
			#'default' enter sequence for state base
			self.__state_vector[2] = self.State.xautomatic_moving_direction_calculation_base
			self.__state_conf_vector_position = 2
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_direction_calculation_base_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_direction_calculation_base_react function.
		"""
		#The reactions of state base.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 2:
				if self.am_gl_update_dat:
					self.__exit_sequence_x_automatic_moving_direction_calculation_base()
					self.__enter_sequence_x_automatic_moving_direction_calculation_calc_default()
					transitioned_after = 2
		return transitioned_after
	
	
	def __x_automatic_moving_grid_interaction_unlogging_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_grid_interaction_unlogging_react function.
		"""
		#The reactions of state unlogging.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 3:
				if self.am_gl_log:
					self.__exit_sequence_x_automatic_moving_grid_interaction_unlogging()
					self.__enter_sequence_x_automatic_moving_grid_interaction_pr_default()
					transitioned_after = 3
		return transitioned_after
	
	
	def __x_automatic_moving_grid_interaction_logging_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_grid_interaction_logging_react function.
		"""
		#The reactions of state logging.
		return transitioned_before
	
	
	def __x_automatic_moving_grid_interaction_logging_r1_first_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_grid_interaction_logging_r1_first_react function.
		"""
		#The reactions of state first.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 3:
				if self.__time_events[3]:
					self.__exit_sequence_x_automatic_moving_grid_interaction_logging_r1_first()
					self.__time_events[3] = False
					self.__enter_sequence_x_automatic_moving_grid_interaction_logging_r1_second_default()
					self.__x_automatic_moving_grid_interaction_logging_react(3)
					transitioned_after = 3
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_grid_interaction_logging_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_grid_interaction_logging_r1_second_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_grid_interaction_logging_r1_second_react function.
		"""
		#The reactions of state second.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 3:
				if self.__time_events[4]:
					self.__exit_sequence_x_automatic_moving_grid_interaction_logging()
					self.raise_am_gl_logged()
					self.__time_events[4] = False
					self.__enter_sequence_x_automatic_moving_grid_interaction_unlogging_default()
					transitioned_after = 3
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_grid_interaction_logging_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_grid_interaction_pr_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_grid_interaction_pr_react function.
		"""
		#The reactions of state pr.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 3:
				if self.__time_events[5]:
					self.__exit_sequence_x_automatic_moving_grid_interaction_pr()
					self.__time_events[5] = False
					self.__enter_sequence_x_automatic_moving_grid_interaction_logging_default()
					transitioned_after = 3
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react function.
		"""
		#The reactions of state moving with lidar.
		return transitioned_before
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state_react function.
		"""
		#The reactions of state base_state.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.laser_distance.d90 > self.grid.grid_size:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
				elif self.laser_distance.d0 < self.grid.grid_size:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
				else:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_react function.
		"""
		#The reactions of state left_wall_disappeared.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_react function.
		"""
		#The reactions of state wall_in_front.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.laser_distance.dm90 <= self.grid.grid_size:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
				elif self.laser_distance.dm90 >= self.grid.grid_size:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_react function.
		"""
		#The reactions of state move_forward.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_move:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right_react function.
		"""
		#The reactions of state need_to_turn_right.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end_react function.
		"""
		#The reactions of state dead_end.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging_react function.
		"""
		#The reactions of state logging.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if (self.am_gl_logged) and (self.grid.row != 0 or self.grid.column != 0):
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
				elif (self.am_gl_logged) and (self.grid.row == 0 and self.grid.column == 0):
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell_react function.
		"""
		#The reactions of state returned_to_initial_cell.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.computer.x_press:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar()
					self.user_var.am_angle_targ = self.start_pos.zero_south_degree
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_turning_south_default()
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_prom_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_prom_react function.
		"""
		#The reactions of state prom.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_prom()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_default()
					transitioned_after = 4
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_turning_south_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_turning_south_react function.
		"""
		#The reactions of state turning_south.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_south()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_turning_left_default()
					transitioned_after = 4
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react function.
		"""
		#The reactions of state moving_withoout_lidar.
		return transitioned_before
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state_react function.
		"""
		#The reactions of state base_state.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if (self.__time_events[6]) and (self.grid.row != self.user_var.am_row_stop or self.grid.column != self.user_var.am_col_stop):
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state()
					self.__time_events[6] = False
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
				elif (self.__time_events[7]) and (self.grid.row == self.user_var.am_row_stop and self.grid.column == self.user_var.am_col_stop):
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state()
					self.__time_events[7] = False
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid_react function.
		"""
		#The reactions of state get_data_from_grid.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.__time_events[8]:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid()
					self.__time_events[8] = False
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision_react function.
		"""
		#The reactions of state start_decision.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.grid.wall_left == 0:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
				elif self.grid.wall_left == 1 and self.grid.wall_front == 0:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
				elif self.grid.wall_left == 1 and self.grid.wall_front == 1 and self.grid.wall_right == 0:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
				elif self.grid.wall_left == 1 and self.grid.wall_front == 1 and self.grid.wall_right == 1:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go_react function.
		"""
		#The reactions of state turn_left_and_go.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright_react function.
		"""
		#The reactions of state go_stright.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state go_stright
			self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar
			self.__state_conf_vector_position = 4
			#'default' enter sequence for state go
			self.__entry_action_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go()
			self.__state_vector[4] = self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go
			self.__state_conf_vector_position = 4
			self.__state_conf_vector_changed = True
			self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go_react function.
		"""
		#The reactions of state turn_right_and_go.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go_react function.
		"""
		#The reactions of state turn_back_and_go.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_react function.
		"""
		#The reactions of state go.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_move:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state_default()
					self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(4)
					transitioned_after = 4
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished_react function.
		"""
		#The reactions of state finished.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_automatic_moving_through_maze_turning_left_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_automatic_moving_through_maze_turning_left_react function.
		"""
		#The reactions of state turning_left.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_automatic_moving_through_maze_turning_left()
					self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_default()
					transitioned_after = 4
		return transitioned_after
	
	
	def __x_automatic_moving_move_normal_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_move_normal_react function.
		"""
		#The reactions of state normal.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 5:
				if self.am_move_gr:
					self.__exit_sequence_x_automatic_moving_move_normal()
					self.__enter_sequence_x_automatic_moving_move_moving_full_default()
					transitioned_after = 5
		return transitioned_after
	
	
	def __x_automatic_moving_move_moving_full_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_move_moving_full_react function.
		"""
		#The reactions of state moving full.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 5:
				if ((((self.odom.x - self.user_var.am_x_mem)) * ((self.odom.x - self.user_var.am_x_mem))) + (((self.odom.y - self.user_var.am_y_mem)) * ((self.odom.y - self.user_var.am_y_mem)))) > (self.grid.grid_size * self.grid.grid_size):
					self.__exit_sequence_x_automatic_moving_move_moving_full()
					self.__enter_sequence_x_automatic_moving_move_precise_default()
					transitioned_after = 5
		return transitioned_after
	
	
	def __x_automatic_moving_move_precise_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_move_precise_react function.
		"""
		#The reactions of state precise.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 5:
				if ((((self.odom.x - self.user_var.am_x_mem)) * ((self.odom.x - self.user_var.am_x_mem))) + (((self.odom.y - self.user_var.am_y_mem)) * ((self.odom.y - self.user_var.am_y_mem)))) < (self.grid.grid_size * self.grid.grid_size):
					self.__exit_sequence_x_automatic_moving_move_precise()
					self.__enter_sequence_x_automatic_moving_move_precise2_default()
					transitioned_after = 5
		return transitioned_after
	
	
	def __x_automatic_moving_move_precise2_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_move_precise2_react function.
		"""
		#The reactions of state precise2.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 5:
				if ((((self.odom.x - self.user_var.am_x_mem)) * ((self.odom.x - self.user_var.am_x_mem))) + (((self.odom.y - self.user_var.am_y_mem)) * ((self.odom.y - self.user_var.am_y_mem)))) > (self.grid.grid_size * self.grid.grid_size):
					self.__exit_sequence_x_automatic_moving_move_precise2()
					self.__enter_sequence_x_automatic_moving_move_normal_default()
					transitioned_after = 5
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_normal_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_normal_react function.
		"""
		#The reactions of state normal.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if self.am_turn_left:
					self.__exit_sequence_x_automatic_moving_turn_high_level_normal()
					self.__enter_sequence_x_automatic_moving_turn_high_level_turn_left_default()
					transitioned_after = 6
				elif self.am_turn_right:
					self.__exit_sequence_x_automatic_moving_turn_high_level_normal()
					self.__enter_sequence_x_automatic_moving_turn_high_level_turn_right_default()
					transitioned_after = 6
				elif self.am_turn_back:
					self.__exit_sequence_x_automatic_moving_turn_high_level_normal()
					self.__enter_sequence_x_automatic_moving_turn_high_level_turn_back_default()
					transitioned_after = 6
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_turn_left_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_turn_left_react function.
		"""
		#The reactions of state turnLeft.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state turnLeft
			self.__state_vector[6] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 6
			#'default' enter sequence for state processingAngle
			self.__entry_action_x_automatic_moving_turn_high_level_processing_angle()
			self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_processing_angle
			self.__state_conf_vector_position = 6
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_turn_right_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_turn_right_react function.
		"""
		#The reactions of state turnRight.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state turnRight
			self.__state_vector[6] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 6
			#'default' enter sequence for state processingAngle
			self.__entry_action_x_automatic_moving_turn_high_level_processing_angle()
			self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_processing_angle
			self.__state_conf_vector_position = 6
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_turn_back_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_turn_back_react function.
		"""
		#The reactions of state turnBack.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state turnBack
			self.__state_vector[6] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 6
			#'default' enter sequence for state processingAngle
			self.__entry_action_x_automatic_moving_turn_high_level_processing_angle()
			self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_processing_angle
			self.__state_conf_vector_position = 6
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_processing_angle_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_processing_angle_react function.
		"""
		#The reactions of state processingAngle.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if self.user_var.am_angle_targ <= -(180.0):
					self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle()
					self.__enter_sequence_x_automatic_moving_turn_high_level_plus_default()
					transitioned_after = 6
				elif self.user_var.am_angle_targ > 180.0:
					self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle()
					self.__enter_sequence_x_automatic_moving_turn_high_level_minus_default()
					transitioned_after = 6
				elif self.__time_events[9]:
					self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle()
					self.__time_events[9] = False
					self.__enter_sequence_x_automatic_moving_turn_high_level_processing_angle2_default()
					transitioned_after = 6
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_plus_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_plus_react function.
		"""
		#The reactions of state plus.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state plus
			self.__state_vector[6] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 6
			#'default' enter sequence for state processingAngle2
			self.__entry_action_x_automatic_moving_turn_high_level_processing_angle2()
			self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_processing_angle2
			self.__state_conf_vector_position = 6
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_minus_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_minus_react function.
		"""
		#The reactions of state minus.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state minus
			self.__state_vector[6] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 6
			#'default' enter sequence for state processingAngle2
			self.__entry_action_x_automatic_moving_turn_high_level_processing_angle2()
			self.__state_vector[6] = self.State.xautomatic_moving_turn_high_level_processing_angle2
			self.__state_conf_vector_position = 6
			self.__state_conf_vector_changed = True
		return transitioned_after
	
	
	def __x_automatic_moving_turn_high_level_processing_angle2_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_high_level_processing_angle2_react function.
		"""
		#The reactions of state processingAngle2.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_turn_high_level_processing_angle2()
					self.__enter_sequence_x_automatic_moving_turn_high_level_normal_default()
					transitioned_after = 6
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_base_state_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_base_state_react function.
		"""
		#The reactions of state base_state.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if (self.am_start_turn) and (self.user_var.am_angle_targ <= 0.0):
					self.__exit_sequence_x_automatic_moving_turn_low_level_base_state()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_default()
					self.__x_automatic_moving_react(0)
					transitioned_after = 7
				elif (self.am_start_turn) and (self.user_var.am_angle_targ >= 0.0):
					self.__exit_sequence_x_automatic_moving_turn_low_level_base_state()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_default()
					self.__x_automatic_moving_react(0)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_negative_angle_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_negative_angle_react function.
		"""
		#The reactions of state turn_to_negative_angle.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position_react function.
		"""
		#The reactions of state get_to_initial_position.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if self.imu.yaw < 60 and self.imu.yaw > 30:
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step_default()
					self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_react(7)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step_react function.
		"""
		#The reactions of state first_step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if (self.imu.yaw < self.user_var.am_angle_targ) or (self.imu.yaw > 90):
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step_default()
					self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_react(7)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step_react function.
		"""
		#The reactions of state second_step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if (self.imu.yaw > self.user_var.am_angle_targ) and (self.imu.yaw < 90):
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step_default()
					self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_react(7)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step_react function.
		"""
		#The reactions of state third_step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if (self.imu.yaw < self.user_var.am_angle_targ) or (self.imu.yaw > 90):
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_negative_angle()
					self.__enter_sequence_x_automatic_moving_turn_low_level_finished_turn_default()
					self.__x_automatic_moving_react(0)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_positive_angle_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_positive_angle_react function.
		"""
		#The reactions of state turn_to_positive_angle.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position_react function.
		"""
		#The reactions of state get_to_initial_position.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if self.imu.yaw > -(60) and self.imu.yaw < -(30):
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step_default()
					self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_react(7)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step_react function.
		"""
		#The reactions of state first_step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if (self.imu.yaw > self.user_var.am_angle_targ) or (self.imu.yaw < -(90)):
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step_default()
					self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_react(7)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step_react function.
		"""
		#The reactions of state second_step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if (self.imu.yaw < self.user_var.am_angle_targ) and (self.imu.yaw > -(90)):
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step()
					self.__enter_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step_default()
					self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_react(7)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step_react function.
		"""
		#The reactions of state third_step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 7:
				if (self.imu.yaw > self.user_var.am_angle_targ) or (self.imu.yaw < -(90)):
					self.__exit_sequence_x_automatic_moving_turn_low_level_turn_to_positive_angle()
					self.__enter_sequence_x_automatic_moving_turn_low_level_finished_turn_default()
					self.__x_automatic_moving_react(0)
					transitioned_after = 7
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_turn_low_level_finished_turn_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_turn_low_level_finished_turn_react function.
		"""
		#The reactions of state finished_turn.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state finished_turn
			self.__state_vector[7] = self.State.xautomatic_moving
			self.__state_conf_vector_position = 7
			#'default' enter sequence for state base_state
			self.__state_vector[7] = self.State.xautomatic_moving_turn_low_level_base_state
			self.__state_conf_vector_position = 7
			self.__state_conf_vector_changed = True
			self.__x_automatic_moving_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_react(transitioned_before)
		return transitioned_after
	
	
	def __x_calibration_react(self, transitioned_before):
		"""Implementation of __x_calibration_react function.
		"""
		#The reactions of state calibration.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#Always execute local reactions.
			transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __x_calibration_calibration_calibrate_react(self, transitioned_before):
		"""Implementation of __x_calibration_calibration_calibrate_react function.
		"""
		#The reactions of state calibrate.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state calibrate
			self.__state_vector[0] = self.State.xcalibration
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state maze_orientation
			self.__entry_action_x_calibration_calibration_maze_orientation()
			self.__state_vector[0] = self.State.xcalibration_calibration_maze_orientation
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_calibration_react(0)
		else:
			#Always execute local reactions.
			transitioned_after = self.__x_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_calibration_calibration_maze_orientation_react(self, transitioned_before):
		"""Implementation of __x_calibration_calibration_maze_orientation_react function.
		"""
		#The reactions of state maze_orientation.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state calibration
			self.__exit_sequence_x_calibration_calibration()
			self.__state_vector[0] = self.State.null_state
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state automatic moving
			self.__enter_sequence_x_automatic_moving_row_calcualtion_default()
			self.__enter_sequence_x_automatic_moving_column_calculation_default()
			self.__enter_sequence_x_automatic_moving_direction_calculation_default()
			self.__enter_sequence_x_automatic_moving_grid_interaction_default()
			self.__enter_sequence_x_automatic_moving_automatic_moving_through_maze_default()
			self.__enter_sequence_x_automatic_moving_move_default()
			self.__enter_sequence_x_automatic_moving_turn_high_level_default()
			self.__enter_sequence_x_automatic_moving_turn_low_level_default()
			self.__react(0)
		else:
			#Always execute local reactions.
			transitioned_after = self.__x_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __clear_in_events(self):
		"""Implementation of __clear_in_events function.
		"""
		self.computer.m_press = False
		self.computer.w_press = False
		self.computer.a_press = False
		self.computer.s_press = False
		self.computer.d_press = False
		self.computer.x_press = False
		self.__time_events[0] = False
		self.__time_events[1] = False
		self.__time_events[2] = False
		self.__time_events[3] = False
		self.__time_events[4] = False
		self.__time_events[5] = False
		self.__time_events[6] = False
		self.__time_events[7] = False
		self.__time_events[8] = False
		self.__time_events[9] = False
	
	
	def __clear_internal_events(self):
		"""Implementation of __clear_internal_events function.
		"""
		self.am_turn_left = False
		self.am_turn_right = False
		self.am_turn_back = False
		self.am_start_turn = False
		self.am_finished_turn = False
		self.am_move_gr = False
		self.am_finished_move = False
		self.am_gl_update_dat = False
		self.am_gl_log = False
		self.am_gl_logged = False
	
	
	def __micro_step(self):
		"""Implementation of __micro_step function.
		"""
		transitioned = -1
		self.__state_conf_vector_position = 0
		state = self.__state_vector[0]
		if state == self.State.xmanual_control_manual_control_region_idle:
			transitioned = self.__x_manual_control_manual_control_region_idle_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_in_action:
			transitioned = self.__x_manual_control_manual_control_region_in_action_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_decreasing_speed:
			transitioned = self.__x_manual_control_manual_control_region_decreasing_speed_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_increasing_speed:
			transitioned = self.__x_manual_control_manual_control_region_increasing_speed_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_turning_right:
			transitioned = self.__x_manual_control_manual_control_region_turning_right_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_turning_left:
			transitioned = self.__x_manual_control_manual_control_region_turning_left_react(transitioned)
		elif state == self.State.xautomatic_moving_row_calcualtion_base_state:
			transitioned = self.__x_automatic_moving_row_calcualtion_base_state_react(transitioned)
		elif state == self.State.xautomatic_moving_row_calcualtion_calc:
			transitioned = self.__x_automatic_moving_row_calcualtion_calc_react(transitioned)
		elif state == self.State.xautomatic_moving_row_calcualtion_zero:
			transitioned = self.__x_automatic_moving_row_calcualtion_zero_react(transitioned)
		elif state == self.State.xautomatic_moving_row_calcualtion_one:
			transitioned = self.__x_automatic_moving_row_calcualtion_one_react(transitioned)
		elif state == self.State.xautomatic_moving_row_calcualtion_two:
			transitioned = self.__x_automatic_moving_row_calcualtion_two_react(transitioned)
		elif state == self.State.xautomatic_moving_row_calcualtion_three:
			transitioned = self.__x_automatic_moving_row_calcualtion_three_react(transitioned)
		elif state == self.State.xcalibration_calibration_calibrate:
			transitioned = self.__x_calibration_calibration_calibrate_react(transitioned)
		elif state == self.State.xcalibration_calibration_maze_orientation:
			transitioned = self.__x_calibration_calibration_maze_orientation_react(transitioned)
		if self.__state_conf_vector_position < 1:
			state = self.__state_vector[1]
			if state == self.State.xautomatic_moving_column_calculation_base_state:
				transitioned = self.__x_automatic_moving_column_calculation_base_state_react(transitioned)
			elif state == self.State.xautomatic_moving_column_calculation_calc:
				transitioned = self.__x_automatic_moving_column_calculation_calc_react(transitioned)
			elif state == self.State.xautomatic_moving_column_calculation_zero:
				transitioned = self.__x_automatic_moving_column_calculation_zero_react(transitioned)
			elif state == self.State.xautomatic_moving_column_calculation_one:
				transitioned = self.__x_automatic_moving_column_calculation_one_react(transitioned)
			elif state == self.State.xautomatic_moving_column_calculation_two:
				transitioned = self.__x_automatic_moving_column_calculation_two_react(transitioned)
			elif state == self.State.xautomatic_moving_column_calculation_three:
				transitioned = self.__x_automatic_moving_column_calculation_three_react(transitioned)
		if self.__state_conf_vector_position < 2:
			state = self.__state_vector[2]
			if state == self.State.xautomatic_moving_direction_calculation_calc:
				transitioned = self.__x_automatic_moving_direction_calculation_calc_react(transitioned)
			elif state == self.State.xautomatic_moving_direction_calculation_north:
				transitioned = self.__x_automatic_moving_direction_calculation_north_react(transitioned)
			elif state == self.State.xautomatic_moving_direction_calculation_south:
				transitioned = self.__x_automatic_moving_direction_calculation_south_react(transitioned)
			elif state == self.State.xautomatic_moving_direction_calculation_west:
				transitioned = self.__x_automatic_moving_direction_calculation_west_react(transitioned)
			elif state == self.State.xautomatic_moving_direction_calculation_east:
				transitioned = self.__x_automatic_moving_direction_calculation_east_react(transitioned)
			elif state == self.State.xautomatic_moving_direction_calculation_base:
				transitioned = self.__x_automatic_moving_direction_calculation_base_react(transitioned)
		if self.__state_conf_vector_position < 3:
			state = self.__state_vector[3]
			if state == self.State.xautomatic_moving_grid_interaction_unlogging:
				transitioned = self.__x_automatic_moving_grid_interaction_unlogging_react(transitioned)
			elif state == self.State.xautomatic_moving_grid_interaction_logging_r1first:
				transitioned = self.__x_automatic_moving_grid_interaction_logging_r1_first_react(transitioned)
			elif state == self.State.xautomatic_moving_grid_interaction_logging_r1second:
				transitioned = self.__x_automatic_moving_grid_interaction_logging_r1_second_react(transitioned)
			elif state == self.State.xautomatic_moving_grid_interaction_pr:
				transitioned = self.__x_automatic_moving_grid_interaction_pr_react(transitioned)
		if self.__state_conf_vector_position < 4:
			state = self.__state_vector[4]
			if state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1base_state:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_base_state_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1need_to_turn_right:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_need_to_turn_right_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1dead_end:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_dead_end_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1logging:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_logging_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_with_lidar_r1returned_to_initial_cell:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_with_lidar_r1_returned_to_initial_cell_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_prom:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_prom_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_turning_south:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_turning_south_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_base_state_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_get_data_from_grid_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_start_decision_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_left_and_go_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_stright_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_right_and_go_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_turn_back_and_go_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_go_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_moving_withoout_lidar_moving_withoout_lidar_finished_react(transitioned)
			elif state == self.State.xautomatic_moving_automatic_moving_through_maze_turning_left:
				transitioned = self.__x_automatic_moving_automatic_moving_through_maze_turning_left_react(transitioned)
		if self.__state_conf_vector_position < 5:
			state = self.__state_vector[5]
			if state == self.State.xautomatic_moving_move_normal:
				transitioned = self.__x_automatic_moving_move_normal_react(transitioned)
			elif state == self.State.xautomatic_moving_move_moving_full:
				transitioned = self.__x_automatic_moving_move_moving_full_react(transitioned)
			elif state == self.State.xautomatic_moving_move_precise:
				transitioned = self.__x_automatic_moving_move_precise_react(transitioned)
			elif state == self.State.xautomatic_moving_move_precise2:
				transitioned = self.__x_automatic_moving_move_precise2_react(transitioned)
		if self.__state_conf_vector_position < 6:
			state = self.__state_vector[6]
			if state == self.State.xautomatic_moving_turn_high_level_normal:
				transitioned = self.__x_automatic_moving_turn_high_level_normal_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_high_level_turn_left:
				transitioned = self.__x_automatic_moving_turn_high_level_turn_left_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_high_level_turn_right:
				transitioned = self.__x_automatic_moving_turn_high_level_turn_right_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_high_level_turn_back:
				transitioned = self.__x_automatic_moving_turn_high_level_turn_back_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_high_level_processing_angle:
				transitioned = self.__x_automatic_moving_turn_high_level_processing_angle_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_high_level_plus:
				transitioned = self.__x_automatic_moving_turn_high_level_plus_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_high_level_minus:
				transitioned = self.__x_automatic_moving_turn_high_level_minus_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_high_level_processing_angle2:
				transitioned = self.__x_automatic_moving_turn_high_level_processing_angle2_react(transitioned)
		if self.__state_conf_vector_position < 7:
			state = self.__state_vector[7]
			if state == self.State.xautomatic_moving_turn_low_level_base_state:
				self.__x_automatic_moving_turn_low_level_base_state_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position:
				self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_get_to_initial_position_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step:
				self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_first_step_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step:
				self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_second_step_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step:
				self.__x_automatic_moving_turn_low_level_turn_to_negative_angle_turn_to_negative_angle_third_step_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position:
				self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_get_to_initial_position_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step:
				self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_first_step_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step:
				self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_second_step_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step:
				self.__x_automatic_moving_turn_low_level_turn_to_positive_angle_turn_to_positive_angle_third_step_react(transitioned)
			elif state == self.State.xautomatic_moving_turn_low_level_finished_turn:
				self.__x_automatic_moving_turn_low_level_finished_turn_react(transitioned)
	
	
	def run_cycle(self):
		"""Implementation of run_cycle function.
		"""
		#Performs a 'run to completion' step.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.__is_executing:
			return
		self.__is_executing = True
		next_event = self.__get_next_event()
		if next_event is not None:
			self.__execute_queued_event(next_event)
		condition_0 = True
		while condition_0:
			self.__do_completion = False
			condition_1 = True
			while condition_1:
				if self.__completed:
					self.__do_completion = True
				self.__completed = False
				self.__micro_step()
				self.__do_completion = False
				condition_1 = self.__completed
			self.__clear_in_events()
			self.__clear_internal_events()
			condition_0 = False
			next_event = self.__get_next_event()
			if next_event is not None:
				self.__execute_queued_event(next_event)
				condition_0 = True
		self.__is_executing = False
	
	
	def enter(self):
		"""Implementation of enter function.
		"""
		#Activates the state machine.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default enter sequence for statechart model
		self.__enter_sequence_x_default()
		self.__do_completion = False
		condition_0 = True
		while condition_0:
			if self.__completed:
				self.__do_completion = True
			self.__completed = False
			self.__micro_step()
			self.__do_completion = False
			condition_0 = self.__completed
		self.__is_executing = False
	
	
	def exit(self):
		"""Implementation of exit function.
		"""
		#Deactivates the state machine.
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default exit sequence for statechart model
		self.__exit_sequence_x()
		self.__state_vector[0] = self.State.null_state
		self.__state_conf_vector_position = 0
		self.__is_executing = False
	
	
	def trigger_without_event(self):
		"""Implementation of triggerWithoutEvent function.
		"""
		self.run_cycle()
	
