"""Implementation of statechart model.
Generated by itemis CREATE code generator.
"""

import queue
import sys, os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))

class Model:
	"""Implementation of the state machine Model.
	"""

	class State:
		""" State Enum
		"""
		(
			xmanual_control,
			xmanual_control_manual_control_region_idle,
			xmanual_control_manual_control_region_in_action,
			xmanual_control_manual_control_region_decreasing_speed,
			xmanual_control_manual_control_region_increasing_speed,
			xmanual_control_manual_control_region_turning_right,
			xmanual_control_manual_control_region_turning_left,
			xautomatic_moving,
			xautomatic_moving_algoritms_algorithms,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar,
			xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn,
			xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn,
			xautomatic_moving_utils_utils,
			xautomatic_moving_utils_utils_r1move_and_turn,
			xautomatic_moving_utils_utils_r1move_and_turn_move_normal,
			xautomatic_moving_utils_utils_r1move_and_turn_move_moving_full,
			xautomatic_moving_utils_utils_r1move_and_turn_move_moving_half,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_normal,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_left,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_right,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_back,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_plus,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_minus,
			xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2,
			xautomatic_moving_utils_utils_r2turn_impl,
			xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal,
			xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation,
			xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation,
			xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2,
			xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3,
			xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2,
			xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3,
			xinitial_calibration,
			xinitial_calibration_initial_calibration_region_start_calibration,
			xinitial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall,
			xinitial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall,
			xinitial_calibration_initial_calibration_region_aligned_perfect_south,
			xinitial_calibration_initial_calibration_region_aligned_y_axis,
			xinitial_calibration_initial_calibration_region_facing_the_top_wall,
			xinitial_calibration_initial_calibration_region_aligned_perfect_east,
			xinitial_calibration_initial_calibration_region_0_5_g,
			xinitial_calibration_initial_calibration_region_1_5_g,
			xinitial_calibration_initial_calibration_region_2_5_g,
			xinitial_calibration_initial_calibration_region_3_5_g,
			xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined,
			xinitial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall,
			xinitial_calibration_initial_calibration_region_need_to_get_away_from_right_wall,
			xinitial_calibration_initial_calibration_region_x_aligned,
			xinitial_calibration_initial_calibration_region_facing_away_from_the_right_wall,
			xinitial_calibration_initial_calibration_region_set_zero,
			null_state
		) = range(75)
	
	
	class UserVar:
		"""Implementation of scope UserVar.
		"""
		
		def __init__(self, statemachine):
			self.base_speed = None
			self.base_rotation = None
			self.startprocedure = None
			self.am_x_mem = None
			self.am_y_mem = None
			self.am_angle_targ = None
			self.am_ct_sp1 = None
			self.am_ct_thr1 = None
			self.am_ct_sp2 = None
			self.am_ct_thr2 = None
			self.am_ct_sp3 = None
			self.am_gl_i_row = None
			self.am_gl_i_col = None
			self.am_gl_x_rel = None
			self.am_gl_y_rel = None
			self.am_gl_x_ind = None
			self.am_gl_y_ind = None
			
			self.statemachine = statemachine
		
	
	class BaseValues:
		"""Implementation of scope BaseValues.
		"""
		
		def __init__(self, statemachine):
			self.max_speed = None
			self.max_rotation = None
			self.degrees_front = None
			self.degrees_right = None
			self.degrees_back = None
			self.degrees_left = None
			
			self.statemachine = statemachine
		
	
	class Output:
		"""Implementation of scope Output.
		"""
		
		def __init__(self, statemachine):
			self.speed = None
			self.rotation = None
			self.obstacles = None
			self.gems = None
			self.finish = None
			
			self.statemachine = statemachine
		
	
	class Grid:
		"""Implementation of scope Grid.
		"""
		
		def __init__(self, statemachine):
			self.update = None
			self.receive = None
			self.column = None
			self.row = None
			self.orientation = None
			self.visited = None
			self.wall_front = None
			self.wall_right = None
			self.wall_back = None
			self.wall_left = None
			self.grid_size = None
			self.max_col = None
			self.max_row = None
			
			self.statemachine = statemachine
		
	
	class StartPos:
		"""Implementation of scope StartPos.
		"""
		
		def __init__(self, statemachine):
			self.set_zero = None
			self.zero_x = None
			self.zero_y = None
			self.zero_south_degree = None
			self.laser_deg_offset = None
			
			self.statemachine = statemachine
		
	
	class Computer:
		"""Implementation of scope Computer.
		"""
		
		def __init__(self, statemachine):
			self.m_press = None
			self.w_press = None
			self.a_press = None
			self.s_press = None
			self.d_press = None
			self.x_press = None
			
			self.statemachine = statemachine
		
		def raise_m_press(self):
			"""Raise method for event m_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_m_press_call)
			self.statemachine.run_cycle()
		
		def __raise_m_press_call(self):
			"""Raise callback for event m_press.
			"""
			self.m_press = True
		
		def raise_w_press(self):
			"""Raise method for event w_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_w_press_call)
			self.statemachine.run_cycle()
		
		def __raise_w_press_call(self):
			"""Raise callback for event w_press.
			"""
			self.w_press = True
		
		def raise_a_press(self):
			"""Raise method for event a_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_a_press_call)
			self.statemachine.run_cycle()
		
		def __raise_a_press_call(self):
			"""Raise callback for event a_press.
			"""
			self.a_press = True
		
		def raise_s_press(self):
			"""Raise method for event s_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_s_press_call)
			self.statemachine.run_cycle()
		
		def __raise_s_press_call(self):
			"""Raise callback for event s_press.
			"""
			self.s_press = True
		
		def raise_d_press(self):
			"""Raise method for event d_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_d_press_call)
			self.statemachine.run_cycle()
		
		def __raise_d_press_call(self):
			"""Raise callback for event d_press.
			"""
			self.d_press = True
		
		def raise_x_press(self):
			"""Raise method for event x_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_x_press_call)
			self.statemachine.run_cycle()
		
		def __raise_x_press_call(self):
			"""Raise callback for event x_press.
			"""
			self.x_press = True
		
	
	class Imu:
		"""Implementation of scope Imu.
		"""
		
		def __init__(self, statemachine):
			self.pitch = None
			self.roll = None
			self.yaw = None
			
			self.statemachine = statemachine
		
	
	class Odom:
		"""Implementation of scope Odom.
		"""
		
		def __init__(self, statemachine):
			self.x = None
			self.y = None
			self.z = None
			
			self.statemachine = statemachine
		
	
	class LaserDistance:
		"""Implementation of scope LaserDistance.
		"""
		
		def __init__(self, statemachine):
			self.d0 = None
			self.d90 = None
			self.d180 = None
			self.dm90 = None
			self.dmin = None
			self.min_deg = None
			self.dmax = None
			self.max_deg = None
			self.dmean = None
			self.dfront_min = None
			self.min_deg_f = None
			self.dfront_max = None
			self.max_deg_f = None
			self.dfront_mean = None
			self.dright_min = None
			self.min_deg_r = None
			self.dright_max = None
			self.max_deg_r = None
			self.dright_mean = None
			self.dback_min = None
			self.min_deg_b = None
			self.dback_max = None
			self.max_deg_b = None
			self.dback_mean = None
			self.dleft_min = None
			self.min_deg_l = None
			self.dleft_max = None
			self.max_deg_l = None
			self.dleft_mean = None
			
			self.statemachine = statemachine
		
	
	class LaserIntensity:
		"""Implementation of scope LaserIntensity.
		"""
		
		def __init__(self, statemachine):
			self.i0 = None
			self.i90 = None
			self.i180 = None
			self.im90 = None
			self.ifront_min = None
			self.ifront_max = None
			self.ifront_mean = None
			self.iright_min = None
			self.iright_max = None
			self.iright_mean = None
			self.iback_min = None
			self.iback_max = None
			self.iback_mean = None
			self.ileft_min = None
			self.ileft_max = None
			self.ileft_mean = None
			
			self.statemachine = statemachine
		
	
	def __init__(self):
		""" Declares all necessary variables including list of states, histories etc. 
		"""
		self.user_var = Model.UserVar(self)
		self.base_values = Model.BaseValues(self)
		self.output = Model.Output(self)
		self.grid = Model.Grid(self)
		self.start_pos = Model.StartPos(self)
		self.computer = Model.Computer(self)
		self.imu = Model.Imu(self)
		self.odom = Model.Odom(self)
		self.laser_distance = Model.LaserDistance(self)
		self.laser_intensity = Model.LaserIntensity(self)
		
		self.__internal_event_queue = queue.Queue()
		self.in_event_queue = queue.Queue()
		self.__is_calibrated = None
		self.__half_grid_size = None
		self.__distance_to_right_wall = None
		self.am_turn_left = None
		self.am_turn_right = None
		self.am_turn_back = None
		self.am_start_turn = None
		self.am_finished_turn = None
		self.am_move_gr = None
		self.am_move_hgr = None
		self.am_finished_move = None
		
		# enumeration of all states:
		self.__State = Model.State
		self.__state_conf_vector_changed = None
		self.__state_vector = [None] * 7
		for __state_index in range(7):
			self.__state_vector[__state_index] = self.State.null_state
		
		# for timed statechart:
		self.timer_service = None
		self.__time_events = [None] * 3
		
		# initializations:
		#Default init sequence for statechart model
		self.__is_calibrated = False
		self.__half_grid_size = 0.24
		self.__distance_to_right_wall = 0.0
		self.user_var.base_speed = 0.05
		self.user_var.base_rotation = 0.2
		self.user_var.startprocedure = True
		self.user_var.am_x_mem = 0.0
		self.user_var.am_y_mem = 0.0
		self.user_var.am_angle_targ = 0
		self.user_var.am_ct_sp1 = 0.2
		self.user_var.am_ct_thr1 = 4.0
		self.user_var.am_ct_sp2 = 0.02
		self.user_var.am_ct_thr2 = 1.0
		self.user_var.am_ct_sp3 = 0.02
		self.user_var.am_gl_i_row = -(1)
		self.user_var.am_gl_i_col = -(1)
		self.user_var.am_gl_x_rel = -(1.0)
		self.user_var.am_gl_y_rel = -(1.0)
		self.user_var.am_gl_x_ind = 0
		self.user_var.am_gl_y_ind = 0
		self.base_values.max_speed = 0.22
		self.base_values.max_rotation = 2.84
		self.base_values.degrees_front = 10
		self.base_values.degrees_right = 10
		self.base_values.degrees_back = 10
		self.base_values.degrees_left = 10
		self.output.speed = 0.0
		self.output.rotation = 0.0
		self.output.obstacles = 0
		self.output.gems = 0
		self.output.finish = 0
		self.grid.update = False
		self.grid.receive = False
		self.grid.column = 0
		self.grid.row = 0
		self.grid.orientation = 0
		self.grid.visited = False
		self.grid.wall_front = 0
		self.grid.wall_right = 0
		self.grid.wall_back = 0
		self.grid.wall_left = 0
		self.grid.grid_size = 0.48
		self.grid.max_col = 3
		self.grid.max_row = 3
		self.start_pos.set_zero = False
		self.start_pos.zero_x = 0.0
		self.start_pos.zero_y = 0.0
		self.start_pos.zero_south_degree = 0.0
		self.start_pos.laser_deg_offset = 0
		self.imu.pitch = 0.0
		self.imu.roll = 0.0
		self.imu.yaw = 0.0
		self.odom.x = 0.0
		self.odom.y = 0.0
		self.odom.z = 0.0
		self.laser_distance.d0 = 0.0
		self.laser_distance.d90 = 0.0
		self.laser_distance.d180 = 0.0
		self.laser_distance.dm90 = 0.0
		self.laser_distance.dmin = 0.0
		self.laser_distance.min_deg = 0
		self.laser_distance.dmax = 0.0
		self.laser_distance.max_deg = 0
		self.laser_distance.dmean = 0.0
		self.laser_distance.dfront_min = 0.0
		self.laser_distance.min_deg_f = 0
		self.laser_distance.dfront_max = 0.0
		self.laser_distance.max_deg_f = 0
		self.laser_distance.dfront_mean = 0.0
		self.laser_distance.dright_min = 0.0
		self.laser_distance.min_deg_r = 0
		self.laser_distance.dright_max = 0.0
		self.laser_distance.max_deg_r = 0
		self.laser_distance.dright_mean = 0.0
		self.laser_distance.dback_min = 0.0
		self.laser_distance.min_deg_b = 0
		self.laser_distance.dback_max = 0.0
		self.laser_distance.max_deg_b = 0
		self.laser_distance.dback_mean = 0.0
		self.laser_distance.dleft_min = 0.0
		self.laser_distance.min_deg_l = 0
		self.laser_distance.dleft_max = 0.0
		self.laser_distance.max_deg_l = 0
		self.laser_distance.dleft_mean = 0.0
		self.laser_intensity.i0 = 0.0
		self.laser_intensity.i90 = 0.0
		self.laser_intensity.i180 = 0.0
		self.laser_intensity.im90 = 0.0
		self.laser_intensity.ifront_min = 0.0
		self.laser_intensity.ifront_max = 0.0
		self.laser_intensity.ifront_mean = 0.0
		self.laser_intensity.iright_min = 0.0
		self.laser_intensity.iright_max = 0.0
		self.laser_intensity.iright_mean = 0.0
		self.laser_intensity.iback_min = 0.0
		self.laser_intensity.iback_max = 0.0
		self.laser_intensity.iback_mean = 0.0
		self.laser_intensity.ileft_min = 0.0
		self.laser_intensity.ileft_max = 0.0
		self.laser_intensity.ileft_mean = 0.0
		self.__completed = False
		self.__do_completion = False
		self.__is_executing = False
		self.__state_conf_vector_position = None
	
	def is_active(self):
		"""Checks if the state machine is active.
		"""
		return self.__state_vector[0] is not self.__State.null_state or self.__state_vector[1] is not self.__State.null_state or self.__state_vector[2] is not self.__State.null_state or self.__state_vector[3] is not self.__State.null_state or self.__state_vector[4] is not self.__State.null_state or self.__state_vector[5] is not self.__State.null_state or self.__state_vector[6] is not self.__State.null_state
	
	def is_final(self):
		"""Checks if the statemachine is final.
		Always returns 'false' since this state machine can never become final.
		"""
		return False
			
	def is_state_active(self, state):
		"""Checks if the state is currently active.
		"""
		s = state
		if s == self.__State.xmanual_control:
			return (self.__state_vector[0] >= self.__State.xmanual_control)\
				and (self.__state_vector[0] <= self.__State.xmanual_control_manual_control_region_turning_left)
		if s == self.__State.xmanual_control_manual_control_region_idle:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_idle
		if s == self.__State.xmanual_control_manual_control_region_in_action:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_in_action
		if s == self.__State.xmanual_control_manual_control_region_decreasing_speed:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_decreasing_speed
		if s == self.__State.xmanual_control_manual_control_region_increasing_speed:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_increasing_speed
		if s == self.__State.xmanual_control_manual_control_region_turning_right:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_turning_right
		if s == self.__State.xmanual_control_manual_control_region_turning_left:
			return self.__state_vector[0] == self.__State.xmanual_control_manual_control_region_turning_left
		if s == self.__State.xautomatic_moving:
			return (self.__state_vector[0] >= self.__State.xautomatic_moving)\
				and (self.__state_vector[0] <= self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3)
		if s == self.__State.xautomatic_moving_algoritms_algorithms:
			return (self.__state_vector[0] >= self.__State.xautomatic_moving_algoritms_algorithms)\
				and (self.__state_vector[0] <= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar:
			return (self.__state_vector[0] >= self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar)\
				and (self.__state_vector[0] <= self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar:
			return (self.__state_vector[0] >= self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar)\
				and (self.__state_vector[0] <= self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder:
			return self.__state_vector[0] == self.__State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid:
			return (self.__state_vector[1] >= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid)\
				and (self.__state_vector[1] <= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging:
			return (self.__state_vector[1] >= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging)\
				and (self.__state_vector[1] <= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging:
			return (self.__state_vector[1] >= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging)\
				and (self.__state_vector[1] <= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging:
			return self.__state_vector[1] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging:
			return (self.__state_vector[1] >= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging)\
				and (self.__state_vector[1] <= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main:
			return self.__state_vector[1] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation:
			return (self.__state_vector[2] >= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation)\
				and (self.__state_vector[2] <= self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second)
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step:
			return self.__state_vector[2] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second:
			return self.__state_vector[2] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep:
			return self.__state_vector[3] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second:
			return self.__state_vector[3] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn:
			return self.__state_vector[1] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn:
			return self.__state_vector[1] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn
		if s == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn:
			return self.__state_vector[1] == self.__State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn
		if s == self.__State.xautomatic_moving_utils_utils:
			return (self.__state_vector[4] >= self.__State.xautomatic_moving_utils_utils)\
				and (self.__state_vector[4] <= self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3)
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn:
			return (self.__state_vector[4] >= self.__State.xautomatic_moving_utils_utils_r1move_and_turn)\
				and (self.__state_vector[4] <= self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2)
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_move_normal:
			return self.__state_vector[4] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_move_normal
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_full:
			return self.__state_vector[4] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_full
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_half:
			return self.__state_vector[4] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_half
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_normal:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_normal
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_left:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_left
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_right:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_right
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_back:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_back
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_plus:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_plus
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_minus:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_minus
		if s == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2:
			return self.__state_vector[5] == self.__State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl:
			return (self.__state_vector[6] >= self.__State.xautomatic_moving_utils_utils_r2turn_impl)\
				and (self.__state_vector[6] <= self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3)
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal:
			return self.__state_vector[6] == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation:
			return self.__state_vector[6] == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation:
			return self.__state_vector[6] == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2:
			return self.__state_vector[6] == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3:
			return self.__state_vector[6] == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2:
			return self.__state_vector[6] == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2
		if s == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3:
			return self.__state_vector[6] == self.__State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3
		if s == self.__State.xinitial_calibration:
			return (self.__state_vector[0] >= self.__State.xinitial_calibration)\
				and (self.__state_vector[0] <= self.__State.xinitial_calibration_initial_calibration_region_set_zero)
		if s == self.__State.xinitial_calibration_initial_calibration_region_start_calibration:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_start_calibration
		if s == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall
		if s == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall
		if s == self.__State.xinitial_calibration_initial_calibration_region_aligned_perfect_south:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_aligned_perfect_south
		if s == self.__State.xinitial_calibration_initial_calibration_region_aligned_y_axis:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_aligned_y_axis
		if s == self.__State.xinitial_calibration_initial_calibration_region_facing_the_top_wall:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_facing_the_top_wall
		if s == self.__State.xinitial_calibration_initial_calibration_region_aligned_perfect_east:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_aligned_perfect_east
		if s == self.__State.xinitial_calibration_initial_calibration_region_0_5_g:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_0_5_g
		if s == self.__State.xinitial_calibration_initial_calibration_region_1_5_g:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_1_5_g
		if s == self.__State.xinitial_calibration_initial_calibration_region_2_5_g:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_2_5_g
		if s == self.__State.xinitial_calibration_initial_calibration_region_3_5_g:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_3_5_g
		if s == self.__State.xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined
		if s == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall
		if s == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_right_wall:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_right_wall
		if s == self.__State.xinitial_calibration_initial_calibration_region_x_aligned:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_x_aligned
		if s == self.__State.xinitial_calibration_initial_calibration_region_facing_away_from_the_right_wall:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_facing_away_from_the_right_wall
		if s == self.__State.xinitial_calibration_initial_calibration_region_set_zero:
			return self.__state_vector[0] == self.__State.xinitial_calibration_initial_calibration_region_set_zero
		return False
		
	def time_elapsed(self, event_id):
		"""Add time events to in event queue
		"""
		if event_id in range(3):
			self.in_event_queue.put(lambda: self.raise_time_event(event_id))
			self.run_cycle()
	
	def raise_time_event(self, event_id):
		"""Raise timed events using the event_id.
		"""
		self.__time_events[event_id] = True
	
	def __execute_queued_event(self, func):
		func()
	
	def __get_next_event(self):
		if not self.__internal_event_queue.empty():
			return self.__internal_event_queue.get()
		if not self.in_event_queue.empty():
			return self.in_event_queue.get()
		return None
	
	
	def raise_am_turn_left(self):
		"""Raise method for event am_turn_left.
		"""
		self.__internal_event_queue.put(self.__raise_am_turn_left_call)
	
	def __raise_am_turn_left_call(self):
		"""Raise callback for event am_turn_left.
		"""
		self.am_turn_left = True
	
	def raise_am_turn_right(self):
		"""Raise method for event am_turn_right.
		"""
		self.__internal_event_queue.put(self.__raise_am_turn_right_call)
	
	def __raise_am_turn_right_call(self):
		"""Raise callback for event am_turn_right.
		"""
		self.am_turn_right = True
	
	def raise_am_turn_back(self):
		"""Raise method for event am_turn_back.
		"""
		self.__internal_event_queue.put(self.__raise_am_turn_back_call)
	
	def __raise_am_turn_back_call(self):
		"""Raise callback for event am_turn_back.
		"""
		self.am_turn_back = True
	
	def raise_am_start_turn(self):
		"""Raise method for event am_start_turn.
		"""
		self.__internal_event_queue.put(self.__raise_am_start_turn_call)
	
	def __raise_am_start_turn_call(self):
		"""Raise callback for event am_start_turn.
		"""
		self.am_start_turn = True
	
	def raise_am_finished_turn(self):
		"""Raise method for event am_finished_turn.
		"""
		self.__internal_event_queue.put(self.__raise_am_finished_turn_call)
	
	def __raise_am_finished_turn_call(self):
		"""Raise callback for event am_finished_turn.
		"""
		self.am_finished_turn = True
	
	def raise_am_move_gr(self):
		"""Raise method for event am_move_gr.
		"""
		self.__internal_event_queue.put(self.__raise_am_move_gr_call)
	
	def __raise_am_move_gr_call(self):
		"""Raise callback for event am_move_gr.
		"""
		self.am_move_gr = True
	
	def raise_am_move_hgr(self):
		"""Raise method for event am_move_hgr.
		"""
		self.__internal_event_queue.put(self.__raise_am_move_hgr_call)
	
	def __raise_am_move_hgr_call(self):
		"""Raise callback for event am_move_hgr.
		"""
		self.am_move_hgr = True
	
	def raise_am_finished_move(self):
		"""Raise method for event am_finished_move.
		"""
		self.__internal_event_queue.put(self.__raise_am_finished_move_call)
	
	def __raise_am_finished_move_call(self):
		"""Raise callback for event am_finished_move.
		"""
		self.am_finished_move = True
	
	def __entry_action_x_manual_control_manual_control_region_idle(self):
		"""Entry action for state 'Idle'..
		"""
		#Entry action for state 'Idle'.
		self.output.speed = 0.0
		self.output.rotation = 0.0
		
	def __entry_action_x_manual_control_manual_control_region_decreasing_speed(self):
		""".
		"""
		#Entry action for state 'Decreasing speed'.
		self.output.speed = (self.output.speed - 0.02) if self.output.speed > 0.02 else 0.0
		self.__completed = True
		
	def __entry_action_x_manual_control_manual_control_region_increasing_speed(self):
		""".
		"""
		#Entry action for state 'Increasing speed'.
		self.output.speed = (self.output.speed + 0.02) if self.output.speed < 0.2 else 0.22
		self.__completed = True
		
	def __entry_action_x_manual_control_manual_control_region_turning_right(self):
		""".
		"""
		#Entry action for state 'Turning right'.
		self.output.rotation = (self.output.rotation - 0.02) if self.output.rotation > -(2.82) else -(2.84)
		self.__completed = True
		
	def __entry_action_x_manual_control_manual_control_region_turning_left(self):
		""".
		"""
		#Entry action for state 'Turning left'.
		self.output.rotation = (self.output.rotation + 0.02) if self.output.rotation < 2.82 else 2.84
		self.__completed = True
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go(self):
		"""Entry action for state 'go'..
		"""
		#Entry action for state 'go'.
		self.raise_am_move_gr()
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go(self):
		"""Entry action for state 'turn and go'..
		"""
		#Entry action for state 'turn and go'.
		self.raise_am_turn_left()
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right(self):
		"""Entry action for state 'to right'..
		"""
		#Entry action for state 'to right'.
		self.raise_am_turn_right()
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward(self):
		"""Entry action for state 'move forward'..
		"""
		#Entry action for state 'move forward'.
		self.raise_am_move_gr()
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return(self):
		"""Entry action for state 'return'..
		"""
		#Entry action for state 'return'.
		self.raise_am_turn_back()
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left(self):
		"""Entry action for state 'turn left'..
		"""
		#Entry action for state 'turn left'.
		self.raise_am_turn_left()
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front(self):
		"""Entry action for state 'wall_in_front'..
		"""
		#Entry action for state 'wall_in_front'.
		self.timer_service.set_timer(self, 0, (2 * 1000), False)
		self.timer_service.set_timer(self, 1, (2 * 1000), False)
		self.output.speed = 0.0
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared(self):
		"""Entry action for state 'left_wall_disappeared'..
		"""
		#Entry action for state 'left_wall_disappeared'.
		self.raise_am_move_hgr()
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving(self):
		"""Entry action for state 'normal_moving'..
		"""
		#Entry action for state 'normal_moving'.
		self.output.speed = 0.05
		self.output.rotation = 0.0
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid(self):
		"""Entry action for state 'log_grid'..
		"""
		#Entry action for state 'log_grid'.
		self.grid.update = True
		self.grid.receive = False
		self.start_pos.zero_x = self.odom.x
		self.start_pos.zero_y = self.odom.y
		self.grid.orientation = 1
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging(self):
		"""Entry action for state 'not logging'..
		"""
		#Entry action for state 'not logging'.
		self.grid.wall_front = -(1)
		self.grid.wall_right = -(1)
		self.grid.wall_back = -(1)
		self.grid.wall_left = -(1)
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main(self):
		"""Entry action for state 'main'..
		"""
		#Entry action for state 'main'.
		self.grid.column = self.user_var.am_gl_i_col
		self.grid.row = self.user_var.am_gl_i_row
		self.grid.wall_left = 1 if self.laser_distance.d90 < 0.5 else 0
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step(self):
		"""Entry action for state 'first_step'..
		"""
		#Entry action for state 'first_step'.
		self.user_var.am_gl_x_rel = (((self.odom.x - self.start_pos.zero_x)) / self.grid.grid_size)
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep(self):
		"""Entry action for state 'firststep'..
		"""
		#Entry action for state 'firststep'.
		self.user_var.am_gl_y_rel = (((self.start_pos.zero_y - self.odom.y)) / self.grid.grid_size)
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn(self):
		"""Entry action for state 'left_turn'..
		"""
		#Entry action for state 'left_turn'.
		self.grid.wall_front = -(1)
		self.grid.wall_right = -(1)
		self.grid.wall_back = -(1)
		self.grid.wall_left = -(1)
		self.grid.orientation = (((self.grid.orientation + 3)) % 4)
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn(self):
		"""Entry action for state 'right_turn'..
		"""
		#Entry action for state 'right_turn'.
		self.grid.wall_front = -(1)
		self.grid.wall_right = -(1)
		self.grid.wall_back = -(1)
		self.grid.wall_left = -(1)
		self.grid.orientation = (((self.grid.orientation + 1)) % 4)
		
	def __entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn(self):
		"""Entry action for state 'back_turn'..
		"""
		#Entry action for state 'back_turn'.
		self.grid.wall_front = -(1)
		self.grid.wall_right = -(1)
		self.grid.wall_back = -(1)
		self.grid.wall_left = -(1)
		self.grid.orientation = (((self.grid.orientation + 2)) % 4)
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal(self):
		"""Entry action for state 'normal'..
		"""
		#Entry action for state 'normal'.
		self.raise_am_finished_move()
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full(self):
		"""Entry action for state 'moving full'..
		"""
		#Entry action for state 'moving full'.
		self.output.speed = 0.049
		self.user_var.am_x_mem = self.odom.x
		self.user_var.am_y_mem = self.odom.y
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half(self):
		"""Entry action for state 'moving half'..
		"""
		#Entry action for state 'moving half'.
		self.output.speed = 0.049
		self.user_var.am_x_mem = self.odom.x
		self.user_var.am_y_mem = self.odom.y
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal(self):
		"""Entry action for state 'normal'..
		"""
		#Entry action for state 'normal'.
		self.output.rotation = 0.0
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left(self):
		""".
		"""
		#Entry action for state 'turnLeft'.
		self.user_var.am_angle_targ = (self.imu.yaw + 90)
		self.__completed = True
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right(self):
		""".
		"""
		#Entry action for state 'turnRight'.
		self.user_var.am_angle_targ = (self.imu.yaw - 90)
		self.__completed = True
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back(self):
		""".
		"""
		#Entry action for state 'turnBack'.
		self.user_var.am_angle_targ = (self.imu.yaw + 180)
		self.__completed = True
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle(self):
		"""Entry action for state 'processingAngle'..
		"""
		#Entry action for state 'processingAngle'.
		self.timer_service.set_timer(self, 2, (1 * 1000), False)
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus(self):
		""".
		"""
		#Entry action for state 'plus'.
		self.user_var.am_angle_targ = self.user_var.am_angle_targ + 360
		self.__completed = True
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus(self):
		""".
		"""
		#Entry action for state 'minus'.
		self.user_var.am_angle_targ = self.user_var.am_angle_targ - 360
		self.__completed = True
		
	def __entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2(self):
		"""Entry action for state 'processingAngle2'..
		"""
		#Entry action for state 'processingAngle2'.
		self.raise_am_start_turn()
		
	def __entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal(self):
		"""Entry action for state 'normal'..
		"""
		#Entry action for state 'normal'.
		self.output.rotation = 0.0
		self.raise_am_finished_turn()
		
	def __entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation(self):
		"""Entry action for state 'negativeRotation'..
		"""
		#Entry action for state 'negativeRotation'.
		self.output.rotation = -(self.user_var.am_ct_sp1)
		
	def __entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation(self):
		"""Entry action for state 'positiveRotation'..
		"""
		#Entry action for state 'positiveRotation'.
		self.output.rotation = self.user_var.am_ct_sp1
		
	def __entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2(self):
		"""Entry action for state 'pR2'..
		"""
		#Entry action for state 'pR2'.
		self.output.rotation = self.user_var.am_ct_sp2
		
	def __entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3(self):
		"""Entry action for state 'pR3'..
		"""
		#Entry action for state 'pR3'.
		self.output.rotation = self.user_var.am_ct_sp3
		
	def __entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2(self):
		"""Entry action for state 'nR2'..
		"""
		#Entry action for state 'nR2'.
		self.output.rotation = -(self.user_var.am_ct_sp2)
		
	def __entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3(self):
		"""Entry action for state 'nR3'..
		"""
		#Entry action for state 'nR3'.
		self.output.rotation = -(self.user_var.am_ct_sp3)
		
	def __entry_action_x_initial_calibration_initial_calibration_region_start_calibration(self):
		"""Entry action for state 'Start calibration'..
		"""
		#Entry action for state 'Start calibration'.
		self.output.speed = 0.0
		self.output.rotation = 0.15 if self.imu.yaw >= 0.0 else -(0.15)
		
	def __entry_action_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall(self):
		"""Entry action for state 'Need to get closer to top wall'..
		"""
		#Entry action for state 'Need to get closer to top wall'.
		self.output.rotation = 0.15
		
	def __entry_action_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall(self):
		"""Entry action for state 'Need to get away from the top wall'..
		"""
		#Entry action for state 'Need to get away from the top wall'.
		self.output.speed = 0.02
		
	def __entry_action_x_initial_calibration_initial_calibration_region_aligned_perfect_south(self):
		"""Entry action for state 'Aligned perfect south'..
		"""
		#Entry action for state 'Aligned perfect south'.
		self.output.rotation = 0.0
		
	def __entry_action_x_initial_calibration_initial_calibration_region_aligned_y_axis(self):
		"""Entry action for state 'Aligned Y axis'..
		"""
		#Entry action for state 'Aligned Y axis'.
		self.output.speed = 0.0
		self.output.rotation = -(0.15) if (self.imu.yaw > -(0.5) and self.imu.yaw < 0.5) else +(0.15)
		
	def __entry_action_x_initial_calibration_initial_calibration_region_facing_the_top_wall(self):
		"""Entry action for state 'Facing the top wall'..
		"""
		#Entry action for state 'Facing the top wall'.
		self.output.rotation = 0.0
		self.output.speed = 0.02
		
	def __entry_action_x_initial_calibration_initial_calibration_region_aligned_perfect_east(self):
		""".
		"""
		#Entry action for state 'Aligned perfect East'.
		self.output.rotation = 0.0
		self.__completed = True
		
	def __entry_action_x_initial_calibration_initial_calibration_region__0_5_g(self):
		"""Entry action for state '0,5 G'..
		"""
		#Entry action for state '0,5 G'.
		self.__distance_to_right_wall = self.__half_grid_size
		
	def __entry_action_x_initial_calibration_initial_calibration_region__1_5_g(self):
		"""Entry action for state '1,5 G'..
		"""
		#Entry action for state '1,5 G'.
		self.__distance_to_right_wall = (self.grid.grid_size + self.__half_grid_size)
		
	def __entry_action_x_initial_calibration_initial_calibration_region__2_5_g(self):
		"""Entry action for state '2,5 G'..
		"""
		#Entry action for state '2,5 G'.
		self.__distance_to_right_wall = ((2.0 * self.grid.grid_size) + self.__half_grid_size)
		
	def __entry_action_x_initial_calibration_initial_calibration_region__3_5_g(self):
		""".
		"""
		#Entry action for state '3,5 G'.
		self.__distance_to_right_wall = ((3.0 * self.grid.grid_size) + self.__half_grid_size)
		self.__completed = True
		
	def __entry_action_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall(self):
		"""Entry action for state 'Need to get closer to right wall'..
		"""
		#Entry action for state 'Need to get closer to right wall'.
		self.output.speed = 0.02
		
	def __entry_action_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall(self):
		"""Entry action for state 'Need to get away from right wall'..
		"""
		#Entry action for state 'Need to get away from right wall'.
		self.output.rotation = 0.15
		
	def __entry_action_x_initial_calibration_initial_calibration_region_x_aligned(self):
		"""Entry action for state 'X aligned'..
		"""
		#Entry action for state 'X aligned'.
		self.output.speed = 0.0
		self.output.rotation = 0.15 if (self.imu.yaw > 89.5 and self.imu.yaw < 90.5) else -(0.15)
		
	def __entry_action_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall(self):
		"""Entry action for state 'Facing away from the right wall'..
		"""
		#Entry action for state 'Facing away from the right wall'.
		self.output.rotation = 0.0
		self.output.speed = 0.02
		
	def __entry_action_x_initial_calibration_initial_calibration_region_set_zero(self):
		""".
		"""
		#Entry action for state 'Set ZERO'.
		self.start_pos.set_zero = True
		self.start_pos.zero_x = self.odom.x
		self.start_pos.zero_y = self.odom.y
		self.start_pos.zero_south_degree = self.imu.yaw
		self.output.rotation = 0.0
		self.output.speed = 0.0
		self.__is_calibrated = True
		self.__completed = True
		
	def __exit_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front(self):
		"""Exit action for state 'wall_in_front'..
		"""
		#Exit action for state 'wall_in_front'.
		self.timer_service.unset_timer(self, 0)
		self.timer_service.unset_timer(self, 1)
		
	def __exit_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle(self):
		"""Exit action for state 'processingAngle'..
		"""
		#Exit action for state 'processingAngle'.
		self.timer_service.unset_timer(self, 2)
		
	def __enter_sequence_x_manual_control_default(self):
		"""'default' enter sequence for state Manual Control.
		"""
		#'default' enter sequence for state Manual Control
		self.__enter_sequence_x_manual_control_manual_control_region_default()
		
	def __enter_sequence_x_manual_control_manual_control_region_idle_default(self):
		"""'default' enter sequence for state Idle.
		"""
		#'default' enter sequence for state Idle
		self.__entry_action_x_manual_control_manual_control_region_idle()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_idle
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_decreasing_speed_default(self):
		"""'default' enter sequence for state Decreasing speed.
		"""
		#'default' enter sequence for state Decreasing speed
		self.__entry_action_x_manual_control_manual_control_region_decreasing_speed()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_decreasing_speed
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_increasing_speed_default(self):
		"""'default' enter sequence for state Increasing speed.
		"""
		#'default' enter sequence for state Increasing speed
		self.__entry_action_x_manual_control_manual_control_region_increasing_speed()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_increasing_speed
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_turning_right_default(self):
		"""'default' enter sequence for state Turning right.
		"""
		#'default' enter sequence for state Turning right
		self.__entry_action_x_manual_control_manual_control_region_turning_right()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_turning_right
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_manual_control_manual_control_region_turning_left_default(self):
		"""'default' enter sequence for state Turning left.
		"""
		#'default' enter sequence for state Turning left
		self.__entry_action_x_manual_control_manual_control_region_turning_left()
		self.__state_vector[0] = self.State.xmanual_control_manual_control_region_turning_left
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_default(self):
		"""'default' enter sequence for state automatic moving.
		"""
		#'default' enter sequence for state automatic moving
		self.__enter_sequence_x_automatic_moving_algoritms_default()
		self.__enter_sequence_x_automatic_moving_utils_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_default(self):
		"""'default' enter sequence for state algorithms.
		"""
		#'default' enter sequence for state algorithms
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_default()
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_default(self):
		"""'default' enter sequence for state moving with lidar.
		"""
		#'default' enter sequence for state moving with lidar
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go_default(self):
		"""'default' enter sequence for state go.
		"""
		#'default' enter sequence for state go
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go_default(self):
		"""'default' enter sequence for state turn and go.
		"""
		#'default' enter sequence for state turn and go
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right_default(self):
		"""'default' enter sequence for state to right.
		"""
		#'default' enter sequence for state to right
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_default(self):
		"""'default' enter sequence for state move forward.
		"""
		#'default' enter sequence for state move forward
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return_default(self):
		"""'default' enter sequence for state return.
		"""
		#'default' enter sequence for state return
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left_default(self):
		"""'default' enter sequence for state turn left.
		"""
		#'default' enter sequence for state turn left
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_default(self):
		"""'default' enter sequence for state wall_in_front.
		"""
		#'default' enter sequence for state wall_in_front
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_default(self):
		"""'default' enter sequence for state left_wall_disappeared.
		"""
		#'default' enter sequence for state left_wall_disappeared
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_default(self):
		"""'default' enter sequence for state normal_moving.
		"""
		#'default' enter sequence for state normal_moving
		self.__entry_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_default(self):
		"""'default' enter sequence for state moving without lidar.
		"""
		#'default' enter sequence for state moving without lidar
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder_default(self):
		"""'default' enter sequence for state placeholder.
		"""
		#'default' enter sequence for state placeholder
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_default(self):
		"""'default' enter sequence for state log_grid.
		"""
		#'default' enter sequence for state log_grid
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid()
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_default(self):
		"""'default' enter sequence for state normal_logging.
		"""
		#'default' enter sequence for state normal_logging
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_default(self):
		"""'default' enter sequence for state normal_logging.
		"""
		#'default' enter sequence for state normal_logging
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_default()
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging_default(self):
		"""'default' enter sequence for state not logging.
		"""
		#'default' enter sequence for state not logging
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging()
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_default(self):
		"""'default' enter sequence for state logging.
		"""
		#'default' enter sequence for state logging
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main_default(self):
		"""'default' enter sequence for state main.
		"""
		#'default' enter sequence for state main
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main()
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_default(self):
		"""'default' enter sequence for state row column calculation.
		"""
		#'default' enter sequence for state row column calculation
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_default()
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step_default(self):
		"""'default' enter sequence for state first_step.
		"""
		#'default' enter sequence for state first_step
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step()
		self.__state_vector[2] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second_default(self):
		"""'default' enter sequence for state second.
		"""
		#'default' enter sequence for state second
		self.__state_vector[2] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second
		self.__state_conf_vector_position = 2
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep_default(self):
		"""'default' enter sequence for state firststep.
		"""
		#'default' enter sequence for state firststep
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep()
		self.__state_vector[3] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep
		self.__state_conf_vector_position = 3
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second_default(self):
		"""'default' enter sequence for state second.
		"""
		#'default' enter sequence for state second
		self.__state_vector[3] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second
		self.__state_conf_vector_position = 3
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn_default(self):
		"""'default' enter sequence for state left_turn.
		"""
		#'default' enter sequence for state left_turn
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn()
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn_default(self):
		"""'default' enter sequence for state right_turn.
		"""
		#'default' enter sequence for state right_turn
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn()
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn_default(self):
		"""'default' enter sequence for state back_turn.
		"""
		#'default' enter sequence for state back_turn
		self.__entry_action_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn()
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_default(self):
		"""'default' enter sequence for state utils.
		"""
		#'default' enter sequence for state utils
		self.__enter_sequence_x_automatic_moving_utils_utils_r1_default()
		self.__enter_sequence_x_automatic_moving_utils_utils_r2_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_default(self):
		"""'default' enter sequence for state move and turn.
		"""
		#'default' enter sequence for state move and turn
		self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_default()
		self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal_default(self):
		"""'default' enter sequence for state normal.
		"""
		#'default' enter sequence for state normal
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal()
		self.__state_vector[4] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_normal
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full_default(self):
		"""'default' enter sequence for state moving full.
		"""
		#'default' enter sequence for state moving full
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full()
		self.__state_vector[4] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_full
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half_default(self):
		"""'default' enter sequence for state moving half.
		"""
		#'default' enter sequence for state moving half
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half()
		self.__state_vector[4] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_half
		self.__state_conf_vector_position = 4
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal_default(self):
		"""'default' enter sequence for state normal.
		"""
		#'default' enter sequence for state normal
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal()
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_normal
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left_default(self):
		"""'default' enter sequence for state turnLeft.
		"""
		#'default' enter sequence for state turnLeft
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left()
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_left
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right_default(self):
		"""'default' enter sequence for state turnRight.
		"""
		#'default' enter sequence for state turnRight
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right()
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_right
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back_default(self):
		"""'default' enter sequence for state turnBack.
		"""
		#'default' enter sequence for state turnBack
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back()
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_back
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus_default(self):
		"""'default' enter sequence for state plus.
		"""
		#'default' enter sequence for state plus
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus()
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_plus
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus_default(self):
		"""'default' enter sequence for state minus.
		"""
		#'default' enter sequence for state minus
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus()
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_minus
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2_default(self):
		"""'default' enter sequence for state processingAngle2.
		"""
		#'default' enter sequence for state processingAngle2
		self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2()
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2
		self.__state_conf_vector_position = 5
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_default(self):
		"""'default' enter sequence for state turnImpl.
		"""
		#'default' enter sequence for state turnImpl
		self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal_default(self):
		"""'default' enter sequence for state normal.
		"""
		#'default' enter sequence for state normal
		self.__entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation_default(self):
		"""'default' enter sequence for state negativeRotation.
		"""
		#'default' enter sequence for state negativeRotation
		self.__entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation_default(self):
		"""'default' enter sequence for state positiveRotation.
		"""
		#'default' enter sequence for state positiveRotation
		self.__entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2_default(self):
		"""'default' enter sequence for state pR2.
		"""
		#'default' enter sequence for state pR2
		self.__entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3_default(self):
		"""'default' enter sequence for state pR3.
		"""
		#'default' enter sequence for state pR3
		self.__entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2_default(self):
		"""'default' enter sequence for state nR2.
		"""
		#'default' enter sequence for state nR2
		self.__entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3_default(self):
		"""'default' enter sequence for state nR3.
		"""
		#'default' enter sequence for state nR3
		self.__entry_action_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3
		self.__state_conf_vector_position = 6
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_default(self):
		"""'default' enter sequence for state Initial calibration.
		"""
		#'default' enter sequence for state Initial calibration
		self.__enter_sequence_x_initial_calibration_initial_calibration_region_default()
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_start_calibration_default(self):
		"""'default' enter sequence for state Start calibration.
		"""
		#'default' enter sequence for state Start calibration
		self.__entry_action_x_initial_calibration_initial_calibration_region_start_calibration()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_start_calibration
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall_default(self):
		"""'default' enter sequence for state Need to get closer to top wall.
		"""
		#'default' enter sequence for state Need to get closer to top wall
		self.__entry_action_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall_default(self):
		"""'default' enter sequence for state Need to get away from the top wall.
		"""
		#'default' enter sequence for state Need to get away from the top wall
		self.__entry_action_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south_default(self):
		"""'default' enter sequence for state Aligned perfect south.
		"""
		#'default' enter sequence for state Aligned perfect south
		self.__entry_action_x_initial_calibration_initial_calibration_region_aligned_perfect_south()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_south
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis_default(self):
		"""'default' enter sequence for state Aligned Y axis.
		"""
		#'default' enter sequence for state Aligned Y axis
		self.__entry_action_x_initial_calibration_initial_calibration_region_aligned_y_axis()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_aligned_y_axis
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_facing_the_top_wall_default(self):
		"""'default' enter sequence for state Facing the top wall.
		"""
		#'default' enter sequence for state Facing the top wall
		self.__entry_action_x_initial_calibration_initial_calibration_region_facing_the_top_wall()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_facing_the_top_wall
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_east_default(self):
		"""'default' enter sequence for state Aligned perfect East.
		"""
		#'default' enter sequence for state Aligned perfect East
		self.__entry_action_x_initial_calibration_initial_calibration_region_aligned_perfect_east()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_east
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region__1_5_g_default(self):
		"""'default' enter sequence for state 1,5 G.
		"""
		#'default' enter sequence for state 1,5 G
		self.__entry_action_x_initial_calibration_initial_calibration_region__1_5_g()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_1_5_g
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region__2_5_g_default(self):
		"""'default' enter sequence for state 2,5 G.
		"""
		#'default' enter sequence for state 2,5 G
		self.__entry_action_x_initial_calibration_initial_calibration_region__2_5_g()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_2_5_g
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region__3_5_g_default(self):
		"""'default' enter sequence for state 3,5 G.
		"""
		#'default' enter sequence for state 3,5 G
		self.__entry_action_x_initial_calibration_initial_calibration_region__3_5_g()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_3_5_g
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined_default(self):
		"""'default' enter sequence for state The distance to right wall is determined.
		"""
		#'default' enter sequence for state The distance to right wall is determined
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall_default(self):
		"""'default' enter sequence for state Need to get closer to right wall.
		"""
		#'default' enter sequence for state Need to get closer to right wall
		self.__entry_action_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall_default(self):
		"""'default' enter sequence for state Need to get away from right wall.
		"""
		#'default' enter sequence for state Need to get away from right wall
		self.__entry_action_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_right_wall
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_x_aligned_default(self):
		"""'default' enter sequence for state X aligned.
		"""
		#'default' enter sequence for state X aligned
		self.__entry_action_x_initial_calibration_initial_calibration_region_x_aligned()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_x_aligned
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall_default(self):
		"""'default' enter sequence for state Facing away from the right wall.
		"""
		#'default' enter sequence for state Facing away from the right wall
		self.__entry_action_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_facing_away_from_the_right_wall
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_set_zero_default(self):
		"""'default' enter sequence for state Set ZERO.
		"""
		#'default' enter sequence for state Set ZERO
		self.__entry_action_x_initial_calibration_initial_calibration_region_set_zero()
		self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_set_zero
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_x_default(self):
		"""'default' enter sequence for region x.
		"""
		#'default' enter sequence for region x
		self.__react_x__entry_default()
		
	def __enter_sequence_x_manual_control_manual_control_region_default(self):
		"""'default' enter sequence for region manual control region.
		"""
		#'default' enter sequence for region manual control region
		self.__react_x_manual_control_manual_control_region__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_default(self):
		"""'default' enter sequence for region algoritms.
		"""
		#'default' enter sequence for region algoritms
		self.__react_x_automatic_moving_algoritms__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_default(self):
		"""'default' enter sequence for region automatic moving through maze.
		"""
		#'default' enter sequence for region automatic moving through maze
		self.__react_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_default(self):
		"""'default' enter sequence for region grid interaction.
		"""
		#'default' enter sequence for region grid interaction
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_default(self):
		"""'default' enter sequence for region log_grid.
		"""
		#'default' enter sequence for region log_grid
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_default(self):
		"""'default' enter sequence for region normal_logging.
		"""
		#'default' enter sequence for region normal_logging
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_default(self):
		"""'default' enter sequence for region logging.
		"""
		#'default' enter sequence for region logging
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_default(self):
		"""'default' enter sequence for region logging.
		"""
		#'default' enter sequence for region logging
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_default(self):
		"""'default' enter sequence for region row column calculation.
		"""
		#'default' enter sequence for region row column calculation
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_default(self):
		"""'default' enter sequence for region column calcualtion.
		"""
		#'default' enter sequence for region column calcualtion
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion__entry_default()
		
	def __enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_default(self):
		"""'default' enter sequence for region row calculation.
		"""
		#'default' enter sequence for region row calculation
		self.__react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation__entry_default()
		
	def __enter_sequence_x_automatic_moving_utils_default(self):
		"""'default' enter sequence for region utils.
		"""
		#'default' enter sequence for region utils
		self.__react_x_automatic_moving_utils__entry_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_x_automatic_moving_utils_utils_r1__entry_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_default(self):
		"""'default' enter sequence for region move.
		"""
		#'default' enter sequence for region move
		self.__react_x_automatic_moving_utils_utils_r1_move_and_turn_move__entry_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_default(self):
		"""'default' enter sequence for region turn high level.
		"""
		#'default' enter sequence for region turn high level
		self.__react_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level__entry_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_default(self):
		"""'default' enter sequence for region r2.
		"""
		#'default' enter sequence for region r2
		self.__react_x_automatic_moving_utils_utils_r2__entry_default()
		
	def __enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_default(self):
		"""'default' enter sequence for region turn low level.
		"""
		#'default' enter sequence for region turn low level
		self.__react_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level__entry_default()
		
	def __enter_sequence_x_initial_calibration_initial_calibration_region_default(self):
		"""'default' enter sequence for region initial calibration region.
		"""
		#'default' enter sequence for region initial calibration region
		self.__react_x_initial_calibration_initial_calibration_region__entry_default()
		
	def __exit_sequence_x_manual_control(self):
		"""Default exit sequence for state Manual Control.
		"""
		#Default exit sequence for state Manual Control
		self.__exit_sequence_x_manual_control_manual_control_region()
		self.__state_vector[0] = self.State.null_state
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_idle(self):
		"""Default exit sequence for state Idle.
		"""
		#Default exit sequence for state Idle
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_in_action(self):
		"""Default exit sequence for state In action.
		"""
		#Default exit sequence for state In action
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_decreasing_speed(self):
		"""Default exit sequence for state Decreasing speed.
		"""
		#Default exit sequence for state Decreasing speed
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_increasing_speed(self):
		"""Default exit sequence for state Increasing speed.
		"""
		#Default exit sequence for state Increasing speed
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_turning_right(self):
		"""Default exit sequence for state Turning right.
		"""
		#Default exit sequence for state Turning right
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_manual_control_manual_control_region_turning_left(self):
		"""Default exit sequence for state Turning left.
		"""
		#Default exit sequence for state Turning left
		self.__state_vector[0] = self.State.xmanual_control
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving(self):
		"""Default exit sequence for state automatic moving.
		"""
		#Default exit sequence for state automatic moving
		self.__exit_sequence_x_automatic_moving_algoritms()
		self.__exit_sequence_x_automatic_moving_utils()
		self.__state_vector[0] = self.State.null_state
		self.__state_vector[1] = self.State.null_state
		self.__state_vector[2] = self.State.null_state
		self.__state_vector[3] = self.State.null_state
		self.__state_vector[4] = self.State.null_state
		self.__state_vector[5] = self.State.null_state
		self.__state_vector[6] = self.State.null_state
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar(self):
		"""Default exit sequence for state moving with lidar.
		"""
		#Default exit sequence for state moving with lidar
		self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go(self):
		"""Default exit sequence for state go.
		"""
		#Default exit sequence for state go
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go(self):
		"""Default exit sequence for state turn and go.
		"""
		#Default exit sequence for state turn and go
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right(self):
		"""Default exit sequence for state to right.
		"""
		#Default exit sequence for state to right
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward(self):
		"""Default exit sequence for state move forward.
		"""
		#Default exit sequence for state move forward
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return(self):
		"""Default exit sequence for state return.
		"""
		#Default exit sequence for state return
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left(self):
		"""Default exit sequence for state turn left.
		"""
		#Default exit sequence for state turn left
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front(self):
		"""Default exit sequence for state wall_in_front.
		"""
		#Default exit sequence for state wall_in_front
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		self.__exit_action_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared(self):
		"""Default exit sequence for state left_wall_disappeared.
		"""
		#Default exit sequence for state left_wall_disappeared
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving(self):
		"""Default exit sequence for state normal_moving.
		"""
		#Default exit sequence for state normal_moving
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar(self):
		"""Default exit sequence for state moving without lidar.
		"""
		#Default exit sequence for state moving without lidar
		self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1()
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder(self):
		"""Default exit sequence for state placeholder.
		"""
		#Default exit sequence for state placeholder
		self.__state_vector[0] = self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging(self):
		"""Default exit sequence for state normal_logging.
		"""
		#Default exit sequence for state normal_logging
		self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging()
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid
		self.__state_vector[2] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid
		self.__state_vector[3] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid
		self.__state_conf_vector_position = 3
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging(self):
		"""Default exit sequence for state not logging.
		"""
		#Default exit sequence for state not logging
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging(self):
		"""Default exit sequence for state logging.
		"""
		#Default exit sequence for state logging
		self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging()
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main(self):
		"""Default exit sequence for state main.
		"""
		#Default exit sequence for state main
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step(self):
		"""Default exit sequence for state first_step.
		"""
		#Default exit sequence for state first_step
		self.__state_vector[2] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation
		self.__state_conf_vector_position = 2
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second(self):
		"""Default exit sequence for state second.
		"""
		#Default exit sequence for state second
		self.__state_vector[2] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation
		self.__state_conf_vector_position = 2
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep(self):
		"""Default exit sequence for state firststep.
		"""
		#Default exit sequence for state firststep
		self.__state_vector[3] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation
		self.__state_conf_vector_position = 3
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second(self):
		"""Default exit sequence for state second.
		"""
		#Default exit sequence for state second
		self.__state_vector[3] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation
		self.__state_conf_vector_position = 3
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn(self):
		"""Default exit sequence for state left_turn.
		"""
		#Default exit sequence for state left_turn
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn(self):
		"""Default exit sequence for state right_turn.
		"""
		#Default exit sequence for state right_turn
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn(self):
		"""Default exit sequence for state back_turn.
		"""
		#Default exit sequence for state back_turn
		self.__state_vector[1] = self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal(self):
		"""Default exit sequence for state normal.
		"""
		#Default exit sequence for state normal
		self.__state_vector[4] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full(self):
		"""Default exit sequence for state moving full.
		"""
		#Default exit sequence for state moving full
		self.__state_vector[4] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half(self):
		"""Default exit sequence for state moving half.
		"""
		#Default exit sequence for state moving half
		self.__state_vector[4] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 4
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal(self):
		"""Default exit sequence for state normal.
		"""
		#Default exit sequence for state normal
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left(self):
		"""Default exit sequence for state turnLeft.
		"""
		#Default exit sequence for state turnLeft
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right(self):
		"""Default exit sequence for state turnRight.
		"""
		#Default exit sequence for state turnRight
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back(self):
		"""Default exit sequence for state turnBack.
		"""
		#Default exit sequence for state turnBack
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle(self):
		"""Default exit sequence for state processingAngle.
		"""
		#Default exit sequence for state processingAngle
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		self.__exit_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus(self):
		"""Default exit sequence for state plus.
		"""
		#Default exit sequence for state plus
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus(self):
		"""Default exit sequence for state minus.
		"""
		#Default exit sequence for state minus
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2(self):
		"""Default exit sequence for state processingAngle2.
		"""
		#Default exit sequence for state processingAngle2
		self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
		self.__state_conf_vector_position = 5
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl(self):
		"""Default exit sequence for state turnImpl.
		"""
		#Default exit sequence for state turnImpl
		self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level()
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal(self):
		"""Default exit sequence for state normal.
		"""
		#Default exit sequence for state normal
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation(self):
		"""Default exit sequence for state negativeRotation.
		"""
		#Default exit sequence for state negativeRotation
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation(self):
		"""Default exit sequence for state positiveRotation.
		"""
		#Default exit sequence for state positiveRotation
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2(self):
		"""Default exit sequence for state pR2.
		"""
		#Default exit sequence for state pR2
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3(self):
		"""Default exit sequence for state pR3.
		"""
		#Default exit sequence for state pR3
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2(self):
		"""Default exit sequence for state nR2.
		"""
		#Default exit sequence for state nR2
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3(self):
		"""Default exit sequence for state nR3.
		"""
		#Default exit sequence for state nR3
		self.__state_vector[6] = self.State.xautomatic_moving_utils_utils_r2turn_impl
		self.__state_conf_vector_position = 6
		
	def __exit_sequence_x_initial_calibration(self):
		"""Default exit sequence for state Initial calibration.
		"""
		#Default exit sequence for state Initial calibration
		self.__exit_sequence_x_initial_calibration_initial_calibration_region()
		self.__state_vector[0] = self.State.null_state
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_start_calibration(self):
		"""Default exit sequence for state Start calibration.
		"""
		#Default exit sequence for state Start calibration
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall(self):
		"""Default exit sequence for state Need to get closer to top wall.
		"""
		#Default exit sequence for state Need to get closer to top wall
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall(self):
		"""Default exit sequence for state Need to get away from the top wall.
		"""
		#Default exit sequence for state Need to get away from the top wall
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south(self):
		"""Default exit sequence for state Aligned perfect south.
		"""
		#Default exit sequence for state Aligned perfect south
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis(self):
		"""Default exit sequence for state Aligned Y axis.
		"""
		#Default exit sequence for state Aligned Y axis
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_facing_the_top_wall(self):
		"""Default exit sequence for state Facing the top wall.
		"""
		#Default exit sequence for state Facing the top wall
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_east(self):
		"""Default exit sequence for state Aligned perfect East.
		"""
		#Default exit sequence for state Aligned perfect East
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region__0_5_g(self):
		"""Default exit sequence for state 0,5 G.
		"""
		#Default exit sequence for state 0,5 G
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region__1_5_g(self):
		"""Default exit sequence for state 1,5 G.
		"""
		#Default exit sequence for state 1,5 G
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region__2_5_g(self):
		"""Default exit sequence for state 2,5 G.
		"""
		#Default exit sequence for state 2,5 G
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region__3_5_g(self):
		"""Default exit sequence for state 3,5 G.
		"""
		#Default exit sequence for state 3,5 G
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined(self):
		"""Default exit sequence for state The distance to right wall is determined.
		"""
		#Default exit sequence for state The distance to right wall is determined
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall(self):
		"""Default exit sequence for state Need to get closer to right wall.
		"""
		#Default exit sequence for state Need to get closer to right wall
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall(self):
		"""Default exit sequence for state Need to get away from right wall.
		"""
		#Default exit sequence for state Need to get away from right wall
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_x_aligned(self):
		"""Default exit sequence for state X aligned.
		"""
		#Default exit sequence for state X aligned
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall(self):
		"""Default exit sequence for state Facing away from the right wall.
		"""
		#Default exit sequence for state Facing away from the right wall
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region_set_zero(self):
		"""Default exit sequence for state Set ZERO.
		"""
		#Default exit sequence for state Set ZERO
		self.__state_vector[0] = self.State.xinitial_calibration
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_x(self):
		"""Default exit sequence for region x.
		"""
		#Default exit sequence for region x
		state = self.__state_vector[0]
		if state == self.State.xmanual_control:
			self.__exit_sequence_x_manual_control()
		elif state == self.State.xmanual_control_manual_control_region_idle:
			self.__exit_sequence_x_manual_control_manual_control_region_idle()
		elif state == self.State.xmanual_control_manual_control_region_in_action:
			self.__exit_sequence_x_manual_control_manual_control_region_in_action()
		elif state == self.State.xmanual_control_manual_control_region_decreasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_decreasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_increasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_increasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_turning_right:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_right()
		elif state == self.State.xmanual_control_manual_control_region_turning_left:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_left()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder()
		elif state == self.State.xinitial_calibration:
			self.__exit_sequence_x_initial_calibration()
		elif state == self.State.xinitial_calibration_initial_calibration_region_start_calibration:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_start_calibration()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_south:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south()
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_y_axis:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis()
		elif state == self.State.xinitial_calibration_initial_calibration_region_facing_the_top_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_facing_the_top_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_east:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_east()
		elif state == self.State.xinitial_calibration_initial_calibration_region_0_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__0_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_1_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__1_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_2_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__2_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_3_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__3_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_right_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_x_aligned:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_x_aligned()
		elif state == self.State.xinitial_calibration_initial_calibration_region_facing_away_from_the_right_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_set_zero:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_set_zero()
		state = self.__state_vector[1]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn()
		state = self.__state_vector[2]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second()
		state = self.__state_vector[3]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second()
		state = self.__state_vector[4]
		if state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_normal:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_full:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_half:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half()
		state = self.__state_vector[5]
		if state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_normal:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_left:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_right:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_back:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_plus:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_minus:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2()
		state = self.__state_vector[6]
		if state == self.State.xautomatic_moving_utils_utils_r2turn_impl:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3()
		
	def __exit_sequence_x_manual_control_manual_control_region(self):
		"""Default exit sequence for region manual control region.
		"""
		#Default exit sequence for region manual control region
		state = self.__state_vector[0]
		if state == self.State.xmanual_control_manual_control_region_idle:
			self.__exit_sequence_x_manual_control_manual_control_region_idle()
		elif state == self.State.xmanual_control_manual_control_region_in_action:
			self.__exit_sequence_x_manual_control_manual_control_region_in_action()
		elif state == self.State.xmanual_control_manual_control_region_decreasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_decreasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_increasing_speed:
			self.__exit_sequence_x_manual_control_manual_control_region_increasing_speed()
		elif state == self.State.xmanual_control_manual_control_region_turning_right:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_right()
		elif state == self.State.xmanual_control_manual_control_region_turning_left:
			self.__exit_sequence_x_manual_control_manual_control_region_turning_left()
		
	def __exit_sequence_x_automatic_moving_algoritms(self):
		"""Default exit sequence for region algoritms.
		"""
		#Default exit sequence for region algoritms
		state = self.__state_vector[0]
		if state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder()
		state = self.__state_vector[1]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn()
		state = self.__state_vector[2]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second()
		state = self.__state_vector[3]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second()
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving()
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder()
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging(self):
		"""Default exit sequence for region normal_logging.
		"""
		#Default exit sequence for region normal_logging
		state = self.__state_vector[1]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main()
		state = self.__state_vector[2]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second()
		state = self.__state_vector[3]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep()
		elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second()
		
	def __exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging(self):
		"""Default exit sequence for region logging.
		"""
		#Default exit sequence for region logging
		state = self.__state_vector[1]
		if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main:
			self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main()
		
	def __exit_sequence_x_automatic_moving_utils(self):
		"""Default exit sequence for region utils.
		"""
		#Default exit sequence for region utils
		state = self.__state_vector[4]
		if state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_normal:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_full:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_half:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half()
		state = self.__state_vector[5]
		if state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_normal:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_left:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_right:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_back:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_plus:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_minus:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus()
		elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2()
		state = self.__state_vector[6]
		if state == self.State.xautomatic_moving_utils_utils_r2turn_impl:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3()
		
	def __exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level(self):
		"""Default exit sequence for region turn low level.
		"""
		#Default exit sequence for region turn low level
		state = self.__state_vector[6]
		if state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2()
		elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3:
			self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3()
		
	def __exit_sequence_x_initial_calibration_initial_calibration_region(self):
		"""Default exit sequence for region initial calibration region.
		"""
		#Default exit sequence for region initial calibration region
		state = self.__state_vector[0]
		if state == self.State.xinitial_calibration_initial_calibration_region_start_calibration:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_start_calibration()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_south:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south()
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_y_axis:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis()
		elif state == self.State.xinitial_calibration_initial_calibration_region_facing_the_top_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_facing_the_top_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_east:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_east()
		elif state == self.State.xinitial_calibration_initial_calibration_region_0_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__0_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_1_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__1_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_2_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__2_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_3_5_g:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region__3_5_g()
		elif state == self.State.xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_right_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_x_aligned:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_x_aligned()
		elif state == self.State.xinitial_calibration_initial_calibration_region_facing_away_from_the_right_wall:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall()
		elif state == self.State.xinitial_calibration_initial_calibration_region_set_zero:
			self.__exit_sequence_x_initial_calibration_initial_calibration_region_set_zero()
		
	def __react_x_manual_control_manual_control_region__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_manual_control_manual_control_region_idle_default()
		
	def __react_x__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_manual_control_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_default()
		
	def __react_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_default()
		
	def __react_x_automatic_moving_algoritms__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_algoritms_algorithms_default()
		
	def __react_x_automatic_moving_utils__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_utils_utils_default()
		
	def __react_x_automatic_moving_utils_utils_r1_move_and_turn_move__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal_default()
		
	def __react_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal_default()
		
	def __react_x_automatic_moving_utils_utils_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_default()
		
	def __react_x_automatic_moving_utils_utils_r2__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_default()
		
	def __react_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal_default()
		
	def __react_x_initial_calibration_initial_calibration_region__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_x_initial_calibration_initial_calibration_region_start_calibration_default()
		
	def __react(self, transitioned_before):
		"""Implementation of __react function.
		"""
		#State machine reactions.
		return transitioned_before
	
	
	def __x_manual_control_react(self, transitioned_before):
		"""Implementation of __x_manual_control_react function.
		"""
		#The reactions of state Manual Control.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.computer.m_press) and (self.__is_calibrated):
					self.__exit_sequence_x_manual_control()
					self.__enter_sequence_x_automatic_moving_default()
					self.__react(0)
					transitioned_after = 0
				elif (self.computer.m_press) and (not self.__is_calibrated):
					self.__exit_sequence_x_manual_control()
					self.__enter_sequence_x_initial_calibration_default()
					self.__react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_idle_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_idle_react function.
		"""
		#The reactions of state Idle.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.a_press:
					self.__exit_sequence_x_manual_control_manual_control_region_idle()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_left_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.d_press:
					self.__exit_sequence_x_manual_control_manual_control_region_idle()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_right_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.w_press:
					self.__exit_sequence_x_manual_control_manual_control_region_idle()
					self.__enter_sequence_x_manual_control_manual_control_region_increasing_speed_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_in_action_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_in_action_react function.
		"""
		#The reactions of state In action.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.w_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_increasing_speed_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.x_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_decreasing_speed_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.s_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_idle_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.d_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_right_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
				elif self.computer.a_press:
					self.__exit_sequence_x_manual_control_manual_control_region_in_action()
					self.__enter_sequence_x_manual_control_manual_control_region_turning_left_default()
					self.__x_manual_control_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_decreasing_speed_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_decreasing_speed_react function.
		"""
		#The reactions of state Decreasing speed.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Decreasing speed
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_increasing_speed_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_increasing_speed_react function.
		"""
		#The reactions of state Increasing speed.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Increasing speed
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_turning_right_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_turning_right_react function.
		"""
		#The reactions of state Turning right.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Turning right
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_manual_control_manual_control_region_turning_left_react(self, transitioned_before):
		"""Implementation of __x_manual_control_manual_control_region_turning_left_react function.
		"""
		#The reactions of state Turning left.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Turning left
			self.__state_vector[0] = self.State.xmanual_control
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state In action
			self.__state_vector[0] = self.State.xmanual_control_manual_control_region_in_action
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_manual_control_react(0)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_manual_control_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_react function.
		"""
		#The reactions of state automatic moving.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.m_press:
					self.__exit_sequence_x_automatic_moving()
					self.__enter_sequence_x_manual_control_default()
					self.__react(0)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_react function.
		"""
		#The reactions of state algorithms.
		return transitioned_before
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react function.
		"""
		#The reactions of state moving with lidar.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if False:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_default()
					transitioned_after = 0
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go_react function.
		"""
		#The reactions of state go.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.am_finished_move:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go_react function.
		"""
		#The reactions of state turn and go.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right_react function.
		"""
		#The reactions of state to right.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_react function.
		"""
		#The reactions of state move forward.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.am_finished_move) and (self.laser_distance.d90 > self.grid.grid_size):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
				elif (self.am_finished_move) and (self.laser_distance.d90 < self.grid.grid_size):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return_react function.
		"""
		#The reactions of state return.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left_react function.
		"""
		#The reactions of state turn left.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_react function.
		"""
		#The reactions of state wall_in_front.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.__time_events[0]) and (self.laser_distance.dm90 < self.grid.grid_size):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
					self.__time_events[0] = False
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
				elif (self.__time_events[1]) and (self.laser_distance.dm90 > 0.5):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front()
					self.__time_events[1] = False
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_react function.
		"""
		#The reactions of state left_wall_disappeared.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.am_finished_move:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_react function.
		"""
		#The reactions of state normal_moving.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d0 < (self.grid.grid_size / 2.0):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
				elif self.laser_distance.d90 > self.grid.grid_size:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_default()
					self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_react function.
		"""
		#The reactions of state moving without lidar.
		return transitioned_before
	
	
	def __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder_react function.
		"""
		#The reactions of state placeholder.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react function.
		"""
		#The reactions of state log_grid.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_react function.
		"""
		#The reactions of state normal_logging.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.am_turn_left:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(1)
					transitioned_after = 3
				elif self.am_turn_right:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(1)
					transitioned_after = 3
				elif self.am_turn_back:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(1)
					transitioned_after = 3
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_react function.
		"""
		#The reactions of state normal_logging.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging_react function.
		"""
		#The reactions of state not logging.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.user_var.am_gl_i_row >= 0 and self.user_var.am_gl_i_col >= 0:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_default()
					transitioned_after = 1
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_react function.
		"""
		#The reactions of state logging.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.user_var.am_gl_i_row < 0 or self.user_var.am_gl_i_col < 0:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging_default()
					transitioned_after = 1
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main_react function.
		"""
		#The reactions of state main.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.user_var.am_gl_i_row >= 0 and self.user_var.am_gl_i_col >= 0:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react function.
		"""
		#The reactions of state row column calculation.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step_react function.
		"""
		#The reactions of state first_step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 2:
				self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step()
				self.user_var.am_gl_x_ind = 0
				self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second_default()
				transitioned_after = 2
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second_react function.
		"""
		#The reactions of state second.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 2:
				if self.user_var.am_gl_x_rel > (self.user_var.am_gl_x_ind + 0.25):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second()
					self.user_var.am_gl_x_ind = self.user_var.am_gl_x_ind + 1
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second_default()
					transitioned_after = 2
				elif self.user_var.am_gl_x_rel > (self.user_var.am_gl_x_ind - 0.25) and self.user_var.am_gl_x_rel < (self.user_var.am_gl_x_ind + 0.25):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second()
					self.user_var.am_gl_i_col = self.user_var.am_gl_x_ind
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step_default()
					transitioned_after = 2
				elif self.user_var.am_gl_x_rel <= (self.user_var.am_gl_x_ind - 0.25) or self.user_var.am_gl_x_rel >= (self.user_var.am_gl_x_ind + 0.25):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second()
					self.user_var.am_gl_i_col = -(1)
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step_default()
					transitioned_after = 2
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep_react function.
		"""
		#The reactions of state firststep.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 3:
				self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep()
				self.user_var.am_gl_y_ind = 0
				self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second_default()
				self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react(2)
				transitioned_after = 3
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second_react function.
		"""
		#The reactions of state second.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 3:
				if self.user_var.am_gl_y_rel > (self.user_var.am_gl_y_ind + 0.25):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second()
					self.user_var.am_gl_y_ind = self.user_var.am_gl_y_ind + 1
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react(2)
					transitioned_after = 3
				elif self.user_var.am_gl_y_rel > (self.user_var.am_gl_y_ind - 0.25) and self.user_var.am_gl_y_rel < (self.user_var.am_gl_y_ind + 0.25):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second()
					self.user_var.am_gl_i_row = self.user_var.am_gl_y_ind
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react(2)
					transitioned_after = 3
				elif self.user_var.am_gl_y_rel <= (self.user_var.am_gl_y_ind - 0.25) or self.user_var.am_gl_y_rel >= (self.user_var.am_gl_y_ind + 0.25):
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second()
					self.user_var.am_gl_i_row = -(1)
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react(2)
					transitioned_after = 3
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn_react function.
		"""
		#The reactions of state left_turn.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn_react function.
		"""
		#The reactions of state right_turn.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn_react function.
		"""
		#The reactions of state back_turn.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn()
					self.__enter_sequence_x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_default()
					self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_react function.
		"""
		#The reactions of state utils.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_react function.
		"""
		#The reactions of state move and turn.
		return transitioned_before
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_move_normal_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_move_normal_react function.
		"""
		#The reactions of state normal.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if self.am_move_hgr:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half_default()
					transitioned_after = 4
				elif self.am_move_gr:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full_default()
					transitioned_after = 4
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full_react function.
		"""
		#The reactions of state moving full.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if ((((self.odom.x - self.user_var.am_x_mem)) * ((self.odom.x - self.user_var.am_x_mem))) + (((self.odom.y - self.user_var.am_y_mem)) * ((self.odom.y - self.user_var.am_y_mem)))) > (self.grid.grid_size * self.grid.grid_size):
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full()
					self.output.speed = 0.0
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal_default()
					transitioned_after = 4
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half_react function.
		"""
		#The reactions of state moving half.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 4:
				if ((((self.odom.x - self.user_var.am_x_mem)) * ((self.odom.x - self.user_var.am_x_mem))) + (((self.odom.y - self.user_var.am_y_mem)) * ((self.odom.y - self.user_var.am_y_mem)))) > ((self.grid.grid_size * self.grid.grid_size) * 0.25):
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half()
					self.output.speed = 0.0
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_move_normal_default()
					transitioned_after = 4
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal_react function.
		"""
		#The reactions of state normal.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 5:
				if self.am_turn_left:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left_default()
					self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
					transitioned_after = 5
				elif self.am_turn_right:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right_default()
					self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
					transitioned_after = 5
				elif self.am_turn_back:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back_default()
					self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
					transitioned_after = 5
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left_react function.
		"""
		#The reactions of state turnLeft.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state turnLeft
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
			self.__state_conf_vector_position = 5
			#'default' enter sequence for state processingAngle
			self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle
			self.__state_conf_vector_position = 5
			self.__state_conf_vector_changed = True
			self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right_react function.
		"""
		#The reactions of state turnRight.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state turnRight
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
			self.__state_conf_vector_position = 5
			#'default' enter sequence for state processingAngle
			self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle
			self.__state_conf_vector_position = 5
			self.__state_conf_vector_changed = True
			self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back_react function.
		"""
		#The reactions of state turnBack.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state turnBack
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
			self.__state_conf_vector_position = 5
			#'default' enter sequence for state processingAngle
			self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle
			self.__state_conf_vector_position = 5
			self.__state_conf_vector_changed = True
			self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle_react function.
		"""
		#The reactions of state processingAngle.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 5:
				if self.user_var.am_angle_targ <= -(180.0):
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus_default()
					self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
					transitioned_after = 5
				elif self.user_var.am_angle_targ > 180.0:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus_default()
					self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
					transitioned_after = 5
				elif self.__time_events[2]:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle()
					self.__time_events[2] = False
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2_default()
					self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
					transitioned_after = 5
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus_react function.
		"""
		#The reactions of state plus.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state plus
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
			self.__state_conf_vector_position = 5
			#'default' enter sequence for state processingAngle2
			self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2()
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2
			self.__state_conf_vector_position = 5
			self.__state_conf_vector_changed = True
			self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus_react function.
		"""
		#The reactions of state minus.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state minus
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn
			self.__state_conf_vector_position = 5
			#'default' enter sequence for state processingAngle2
			self.__entry_action_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2()
			self.__state_vector[5] = self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2
			self.__state_conf_vector_position = 5
			self.__state_conf_vector_changed = True
			self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2_react function.
		"""
		#The reactions of state processingAngle2.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 5:
				if self.am_finished_turn:
					self.__exit_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2()
					self.__enter_sequence_x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal_default()
					self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(4)
					transitioned_after = 5
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r1_move_and_turn_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_react function.
		"""
		#The reactions of state turnImpl.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal_react function.
		"""
		#The reactions of state normal.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if (self.am_start_turn) and (self.user_var.am_angle_targ <= 0.0):
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
				elif (self.am_start_turn) and (self.user_var.am_angle_targ >= 0.0):
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r2_turn_impl_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation_react function.
		"""
		#The reactions of state negativeRotation.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if (self.imu.yaw - self.user_var.am_angle_targ) > 0.0 and (self.imu.yaw - self.user_var.am_angle_targ) < self.user_var.am_ct_thr1:
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r2_turn_impl_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation_react function.
		"""
		#The reactions of state positiveRotation.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if (self.imu.yaw - self.user_var.am_angle_targ) < 0.0 and (self.imu.yaw - self.user_var.am_angle_targ) > -(self.user_var.am_ct_thr1):
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r2_turn_impl_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2_react function.
		"""
		#The reactions of state pR2.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if (self.imu.yaw - self.user_var.am_angle_targ) > -(self.user_var.am_ct_thr2):
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r2_turn_impl_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3_react function.
		"""
		#The reactions of state pR3.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if (self.imu.yaw - self.user_var.am_angle_targ) > 0.0 or self.imu.yaw < -(90.0):
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r2_turn_impl_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2_react function.
		"""
		#The reactions of state nR2.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if (self.imu.yaw - self.user_var.am_angle_targ) < self.user_var.am_ct_thr2:
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r2_turn_impl_react(transitioned_before)
		return transitioned_after
	
	
	def __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3_react(self, transitioned_before):
		"""Implementation of __x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3_react function.
		"""
		#The reactions of state nR3.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 6:
				if (self.imu.yaw - self.user_var.am_angle_targ) < 0.0 or self.imu.yaw > 90.0:
					self.__exit_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3()
					self.__enter_sequence_x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal_default()
					self.__x_automatic_moving_utils_utils_r2_turn_impl_react(6)
					transitioned_after = 6
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_automatic_moving_utils_utils_r2_turn_impl_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_react function.
		"""
		#The reactions of state Initial calibration.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#Always execute local reactions.
			transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_start_calibration_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_start_calibration_react function.
		"""
		#The reactions of state Start calibration.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.imu.yaw < -(179.5) and self.imu.yaw > -(180.5) or self.imu.yaw > 179.5 and self.imu.yaw < 180.5:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_start_calibration()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall_react function.
		"""
		#The reactions of state Need to get closer to top wall.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.imu.yaw < 0.5 and self.imu.yaw > -(0.5):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_facing_the_top_wall_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall_react function.
		"""
		#The reactions of state Need to get away from the top wall.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d180 < (self.__half_grid_size + 0.02) and self.laser_distance.d180 > (self.__half_grid_size - 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_aligned_perfect_south_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_aligned_perfect_south_react function.
		"""
		#The reactions of state Aligned perfect south.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d180 > self.__half_grid_size:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
				elif self.laser_distance.d180 < self.__half_grid_size:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
				elif self.laser_distance.d180 == self.__half_grid_size:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_south()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_aligned_y_axis_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_aligned_y_axis_react function.
		"""
		#The reactions of state Aligned Y axis.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.imu.yaw < -(89.5) and self.imu.yaw > -(90.5):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_aligned_perfect_east_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_facing_the_top_wall_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_facing_the_top_wall_react function.
		"""
		#The reactions of state Facing the top wall.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d0 < (self.__half_grid_size + 0.02) and self.laser_distance.d0 > (self.__half_grid_size - 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_facing_the_top_wall()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_aligned_y_axis_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_aligned_perfect_east_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_aligned_perfect_east_react function.
		"""
		#The reactions of state Aligned perfect East.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Aligned perfect East
			self.__state_vector[0] = self.State.xinitial_calibration
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state 0,5 G
			self.__entry_action_x_initial_calibration_initial_calibration_region__0_5_g()
			self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_0_5_g
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_initial_calibration_react(0)
		else:
			#Always execute local reactions.
			transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region__0_5_g_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region__0_5_g_react function.
		"""
		#The reactions of state 0,5 G.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d0 >= (self.grid.grid_size - 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region__0_5_g()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region__1_5_g_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
				elif self.laser_distance.d0 < self.grid.grid_size:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region__0_5_g()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region__1_5_g_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region__1_5_g_react function.
		"""
		#The reactions of state 1,5 G.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d0 >= ((2 * self.grid.grid_size) - 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region__1_5_g()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region__2_5_g_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
				elif self.laser_distance.d0 < (2.0 * self.grid.grid_size):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region__1_5_g()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region__2_5_g_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region__2_5_g_react function.
		"""
		#The reactions of state 2,5 G.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d0 >= ((3 * self.grid.grid_size) - 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region__2_5_g()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region__3_5_g_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
				elif self.laser_distance.d0 < (3.0 * self.grid.grid_size):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region__2_5_g()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region__3_5_g_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region__3_5_g_react function.
		"""
		#The reactions of state 3,5 G.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state 3,5 G
			self.__state_vector[0] = self.State.xinitial_calibration
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state The distance to right wall is determined
			self.__state_vector[0] = self.State.xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined
			self.__state_conf_vector_position = 0
			self.__state_conf_vector_changed = True
			self.__x_initial_calibration_react(0)
		else:
			#Always execute local reactions.
			transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined_react function.
		"""
		#The reactions of state The distance to right wall is determined.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d0 > self.__distance_to_right_wall:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
				elif self.laser_distance.d0 > (self.__distance_to_right_wall - 0.02) and self.laser_distance.d0 < (self.__distance_to_right_wall + 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_x_aligned_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
				elif self.laser_distance.d0 < self.__distance_to_right_wall:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall_react function.
		"""
		#The reactions of state Need to get closer to right wall.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d0 < (self.__distance_to_right_wall + 0.02) and self.laser_distance.d0 > (self.__distance_to_right_wall - 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_x_aligned_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall_react function.
		"""
		#The reactions of state Need to get away from right wall.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.imu.yaw < 90.5 and self.imu.yaw > 89.5:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_x_aligned_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_x_aligned_react function.
		"""
		#The reactions of state X aligned.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.imu.yaw < -(179.5) and self.imu.yaw > -(180.5) or self.imu.yaw > 179.5 and self.imu.yaw < 180.5:
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_x_aligned()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_set_zero_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall_react function.
		"""
		#The reactions of state Facing away from the right wall.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.d180 < (self.__distance_to_right_wall + 0.02) and self.laser_distance.d180 > (self.__distance_to_right_wall - 0.02):
					self.__exit_sequence_x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall()
					self.__enter_sequence_x_initial_calibration_initial_calibration_region_x_aligned_default()
					self.__x_initial_calibration_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __x_initial_calibration_initial_calibration_region_set_zero_react(self, transitioned_before):
		"""Implementation of __x_initial_calibration_initial_calibration_region_set_zero_react function.
		"""
		#The reactions of state Set ZERO.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state Initial calibration
			self.__exit_sequence_x_initial_calibration_initial_calibration_region()
			self.__state_vector[0] = self.State.null_state
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state automatic moving
			self.__enter_sequence_x_automatic_moving_algoritms_default()
			self.__enter_sequence_x_automatic_moving_utils_default()
			self.__react(0)
		else:
			#Always execute local reactions.
			transitioned_after = self.__x_initial_calibration_react(transitioned_before)
		return transitioned_after
	
	
	def __clear_in_events(self):
		"""Implementation of __clear_in_events function.
		"""
		self.computer.m_press = False
		self.computer.w_press = False
		self.computer.a_press = False
		self.computer.s_press = False
		self.computer.d_press = False
		self.computer.x_press = False
		self.__time_events[0] = False
		self.__time_events[1] = False
		self.__time_events[2] = False
	
	
	def __clear_internal_events(self):
		"""Implementation of __clear_internal_events function.
		"""
		self.am_turn_left = False
		self.am_turn_right = False
		self.am_turn_back = False
		self.am_start_turn = False
		self.am_finished_turn = False
		self.am_move_gr = False
		self.am_move_hgr = False
		self.am_finished_move = False
	
	
	def __micro_step(self):
		"""Implementation of __micro_step function.
		"""
		transitioned = -1
		self.__state_conf_vector_position = 0
		state = self.__state_vector[0]
		if state == self.State.xmanual_control_manual_control_region_idle:
			transitioned = self.__x_manual_control_manual_control_region_idle_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_in_action:
			transitioned = self.__x_manual_control_manual_control_region_in_action_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_decreasing_speed:
			transitioned = self.__x_manual_control_manual_control_region_decreasing_speed_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_increasing_speed:
			transitioned = self.__x_manual_control_manual_control_region_increasing_speed_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_turning_right:
			transitioned = self.__x_manual_control_manual_control_region_turning_right_react(transitioned)
		elif state == self.State.xmanual_control_manual_control_region_turning_left:
			transitioned = self.__x_manual_control_manual_control_region_turning_left_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1go:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_go_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_and_go:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_and_go_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1to_right:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_to_right_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1move_forward:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_move_forward_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1return:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_return_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1turn_left:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_turn_left_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1wall_in_front:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_wall_in_front_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1left_wall_disappeared:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_left_wall_disappeared_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1normal_moving:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_with_lidar_r1_normal_moving_react(transitioned)
		elif state == self.State.xautomatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1placeholder:
			transitioned = self.__x_automatic_moving_algoritms_algorithms_automatic_moving_through_maze_moving_without_lidar_r1_placeholder_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_start_calibration:
			transitioned = self.__x_initial_calibration_initial_calibration_region_start_calibration_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall:
			transitioned = self.__x_initial_calibration_initial_calibration_region_need_to_get_closer_to_top_wall_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall:
			transitioned = self.__x_initial_calibration_initial_calibration_region_need_to_get_away_from_the_top_wall_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_south:
			transitioned = self.__x_initial_calibration_initial_calibration_region_aligned_perfect_south_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_y_axis:
			transitioned = self.__x_initial_calibration_initial_calibration_region_aligned_y_axis_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_facing_the_top_wall:
			transitioned = self.__x_initial_calibration_initial_calibration_region_facing_the_top_wall_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_aligned_perfect_east:
			transitioned = self.__x_initial_calibration_initial_calibration_region_aligned_perfect_east_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_0_5_g:
			transitioned = self.__x_initial_calibration_initial_calibration_region__0_5_g_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_1_5_g:
			transitioned = self.__x_initial_calibration_initial_calibration_region__1_5_g_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_2_5_g:
			transitioned = self.__x_initial_calibration_initial_calibration_region__2_5_g_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_3_5_g:
			transitioned = self.__x_initial_calibration_initial_calibration_region__3_5_g_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined:
			transitioned = self.__x_initial_calibration_initial_calibration_region_the_distance_to_right_wall_is_determined_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall:
			transitioned = self.__x_initial_calibration_initial_calibration_region_need_to_get_closer_to_right_wall_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_need_to_get_away_from_right_wall:
			transitioned = self.__x_initial_calibration_initial_calibration_region_need_to_get_away_from_right_wall_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_x_aligned:
			transitioned = self.__x_initial_calibration_initial_calibration_region_x_aligned_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_facing_away_from_the_right_wall:
			transitioned = self.__x_initial_calibration_initial_calibration_region_facing_away_from_the_right_wall_react(transitioned)
		elif state == self.State.xinitial_calibration_initial_calibration_region_set_zero:
			transitioned = self.__x_initial_calibration_initial_calibration_region_set_zero_react(transitioned)
		if self.__state_conf_vector_position < 1:
			state = self.__state_vector[1]
			if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_not_logging_react(transitioned)
			elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_logging_logging_logging_main_react(transitioned)
			elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_left_turn_react(transitioned)
			elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_right_turn_react(transitioned)
			elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_back_turn_react(transitioned)
		if self.__state_conf_vector_position < 2:
			state = self.__state_vector[2]
			if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_first_step_react(transitioned)
			elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_column_calcualtion_second_react(transitioned)
		if self.__state_conf_vector_position < 3:
			state = self.__state_vector[3]
			if state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_firststep_react(transitioned)
			elif state == self.State.xautomatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second:
				transitioned = self.__x_automatic_moving_algoritms_algorithms_grid_interaction_log_grid_log_grid_normal_logging_normal_logging_normal_logging_row_column_calculation_row_column_calculation_row_calculation_second_react(transitioned)
		if self.__state_conf_vector_position < 4:
			state = self.__state_vector[4]
			if state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_normal:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_move_normal_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_full:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_full_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_move_moving_half:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_move_moving_half_react(transitioned)
		if self.__state_conf_vector_position < 5:
			state = self.__state_vector[5]
			if state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_normal:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_normal_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_left:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_left_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_right:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_right_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_turn_back:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_turn_back_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_plus:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_plus_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_minus:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_minus_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r1move_and_turn_turn_high_level_processing_angle2:
				transitioned = self.__x_automatic_moving_utils_utils_r1_move_and_turn_turn_high_level_processing_angle2_react(transitioned)
		if self.__state_conf_vector_position < 6:
			state = self.__state_vector[6]
			if state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_normal:
				self.__x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_normal_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_negative_rotation:
				self.__x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_negative_rotation_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_positive_rotation:
				self.__x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_positive_rotation_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr2:
				self.__x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r2_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_pr3:
				self.__x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_p_r3_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr2:
				self.__x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r2_react(transitioned)
			elif state == self.State.xautomatic_moving_utils_utils_r2turn_impl_turn_low_level_nr3:
				self.__x_automatic_moving_utils_utils_r2_turn_impl_turn_low_level_n_r3_react(transitioned)
	
	
	def run_cycle(self):
		"""Implementation of run_cycle function.
		"""
		#Performs a 'run to completion' step.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.__is_executing:
			return
		self.__is_executing = True
		next_event = self.__get_next_event()
		if next_event is not None:
			self.__execute_queued_event(next_event)
		condition_0 = True
		while condition_0:
			self.__do_completion = False
			condition_1 = True
			while condition_1:
				if self.__completed:
					self.__do_completion = True
				self.__completed = False
				self.__micro_step()
				self.__do_completion = False
				condition_1 = self.__completed
			self.__clear_in_events()
			self.__clear_internal_events()
			condition_0 = False
			next_event = self.__get_next_event()
			if next_event is not None:
				self.__execute_queued_event(next_event)
				condition_0 = True
		self.__is_executing = False
	
	
	def enter(self):
		"""Implementation of enter function.
		"""
		#Activates the state machine.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default enter sequence for statechart model
		self.__enter_sequence_x_default()
		self.__do_completion = False
		condition_0 = True
		while condition_0:
			if self.__completed:
				self.__do_completion = True
			self.__completed = False
			self.__micro_step()
			self.__do_completion = False
			condition_0 = self.__completed
		self.__is_executing = False
	
	
	def exit(self):
		"""Implementation of exit function.
		"""
		#Deactivates the state machine.
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default exit sequence for statechart model
		self.__exit_sequence_x()
		self.__state_vector[0] = self.State.null_state
		self.__state_conf_vector_position = 0
		self.__is_executing = False
	
	
	def trigger_without_event(self):
		"""Implementation of triggerWithoutEvent function.
		"""
		self.run_cycle()
	
